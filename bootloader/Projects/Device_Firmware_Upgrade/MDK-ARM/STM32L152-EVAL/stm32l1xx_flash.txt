; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_flash.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_flash.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_flash.crf ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash.c]
                          THUMB

                          AREA ||i.DATA_EEPROM_EraseByte||, CODE, READONLY, ALIGN=1

                  DATA_EEPROM_EraseByte PROC
;;;509      */
;;;510    FLASH_Status DATA_EEPROM_EraseByte(uint32_t Address)
000000  b510              PUSH     {r4,lr}
;;;511    {
000002  4604              MOV      r4,r0
;;;512      FLASH_Status status = FLASH_COMPLETE;
;;;513      
;;;514      /* Check the parameters */
;;;515      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;516      
;;;517      /* Wait for last operation to be completed */
;;;518      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4000          MOV      r0,#0x8000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;519      
;;;520      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d101              BNE      |L1.20|
;;;521      {
;;;522        /* Write "00h" to valid address in the data memory" */
;;;523        *(__IO uint8_t *) Address = (uint8_t)0x00;
000010  2100              MOVS     r1,#0
000012  7021              STRB     r1,[r4,#0]
                  |L1.20|
;;;524      }
;;;525       
;;;526      /* Return the erase status */
;;;527      return status;
;;;528    }
000014  bd10              POP      {r4,pc}
;;;529    
                          ENDP


                          AREA ||i.DATA_EEPROM_EraseHalfWord||, CODE, READONLY, ALIGN=1

                  DATA_EEPROM_EraseHalfWord PROC
;;;542      */
;;;543    FLASH_Status DATA_EEPROM_EraseHalfWord(uint32_t Address)
000000  b510              PUSH     {r4,lr}
;;;544    {
000002  4604              MOV      r4,r0
;;;545      FLASH_Status status = FLASH_COMPLETE;
;;;546      
;;;547      /* Check the parameters */
;;;548      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;549      
;;;550      /* Wait for last operation to be completed */
;;;551      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4000          MOV      r0,#0x8000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;552      
;;;553      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d101              BNE      |L2.20|
;;;554      {
;;;555        /* Write "0000h" to valid address in the data memory" */
;;;556        *(__IO uint16_t *) Address = (uint16_t)0x0000;
000010  2100              MOVS     r1,#0
000012  8021              STRH     r1,[r4,#0]
                  |L2.20|
;;;557      }
;;;558       
;;;559      /* Return the erase status */
;;;560      return status;
;;;561    }
000014  bd10              POP      {r4,pc}
;;;562    
                          ENDP


                          AREA ||i.DATA_EEPROM_EraseWord||, CODE, READONLY, ALIGN=1

                  DATA_EEPROM_EraseWord PROC
;;;575      */
;;;576    FLASH_Status DATA_EEPROM_EraseWord(uint32_t Address)
000000  b510              PUSH     {r4,lr}
;;;577    {
000002  4604              MOV      r4,r0
;;;578      FLASH_Status status = FLASH_COMPLETE;
;;;579      
;;;580      /* Check the parameters */
;;;581      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;582      
;;;583      /* Wait for last operation to be completed */
;;;584      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4000          MOV      r0,#0x8000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;585      
;;;586      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d101              BNE      |L3.20|
;;;587      {
;;;588        /* Write "00000000h" to valid address in the data memory" */
;;;589        *(__IO uint32_t *) Address = 0x00000000;
000010  2100              MOVS     r1,#0
000012  6021              STR      r1,[r4,#0]
                  |L3.20|
;;;590      }
;;;591       
;;;592      /* Return the erase status */
;;;593      return status;
;;;594    }
000014  bd10              POP      {r4,pc}
;;;595    
                          ENDP


                          AREA ||i.DATA_EEPROM_FastProgramByte||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_FastProgramByte PROC
;;;608      */
;;;609    FLASH_Status DATA_EEPROM_FastProgramByte(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;610    {
000002  4605              MOV      r5,r0
;;;611      FLASH_Status status = FLASH_COMPLETE;
;;;612    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;613      uint32_t tmp = 0, tmpaddr = 0;
;;;614    #endif
;;;615      
;;;616      /* Check the parameters */
;;;617      assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
;;;618    
;;;619      /* Wait for last operation to be completed */
;;;620      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460c              MOV      r4,r1                 ;610
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;621        
;;;622      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d11c              BNE      |L4.78|
;;;623      {
;;;624        /* Clear the FTDW bit */
;;;625        FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
000014  480e              LDR      r0,|L4.80|
000016  6801              LDR      r1,[r0,#0]
000018  f4217180          BIC      r1,r1,#0x100
00001c  6001              STR      r1,[r0,#0]
;;;626    
;;;627    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;628        if(Data != (uint8_t)0x00) 
00001e  b12c              CBZ      r4,|L4.44|
;;;629        {
;;;630          /* If the previous operation is completed, proceed to write the new Data */
;;;631          *(__IO uint8_t *)Address = Data;
000020  702c              STRB     r4,[r5,#0]
;;;632                
;;;633          /* Wait for last operation to be completed */
;;;634          status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000022  4630              MOV      r0,r6
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L4.44|
;;;635        }
;;;636        else
;;;637        {
;;;638          tmpaddr = Address & 0xFFFFFFFC;
00002c  f0250603          BIC      r6,r5,#3
;;;639          tmp = * (__IO uint32_t *) tmpaddr;
000030  6834              LDR      r4,[r6,#0]
;;;640          tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
000032  07a8              LSLS     r0,r5,#30
000034  0ec1              LSRS     r1,r0,#27
000036  20ff              MOVS     r0,#0xff
000038  4088              LSLS     r0,r0,r1
;;;641          tmp &= ~tmpaddr;
00003a  4384              BICS     r4,r4,r0
00003c  4630              MOV      r0,r6
;;;642          status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
00003e  f7fffffe          BL       DATA_EEPROM_EraseWord
;;;643          status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
000042  4621              MOV      r1,r4
000044  4630              MOV      r0,r6
000046  e8bd4070          POP      {r4-r6,lr}
00004a  f7ffbffe          B.W      DATA_EEPROM_FastProgramWord
                  |L4.78|
;;;644        }       
;;;645    #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP)
;;;646        /* If the previous operation is completed, proceed to write the new Data */
;;;647        *(__IO uint8_t *)Address = Data;
;;;648                
;;;649        /* Wait for last operation to be completed */
;;;650        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
;;;651    #endif  
;;;652      }
;;;653      /* Return the Write Status */
;;;654      return status;
;;;655    }
00004e  bd70              POP      {r4-r6,pc}
;;;656    
                          ENDP

                  |L4.80|
                          DCD      0x40023c04

                          AREA ||i.DATA_EEPROM_FastProgramHalfWord||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_FastProgramHalfWord PROC
;;;669      */
;;;670    FLASH_Status DATA_EEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;671    {
000002  4604              MOV      r4,r0
;;;672      FLASH_Status status = FLASH_COMPLETE;
;;;673    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;674      uint32_t tmp = 0, tmpaddr = 0;
;;;675    #endif
;;;676      
;;;677      /* Check the parameters */
;;;678      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;679    
;;;680      /* Wait for last operation to be completed */
;;;681      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4700          MOV      r7,#0x8000
000008  460e              MOV      r6,r1                 ;671
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4605              MOV      r5,r0
;;;682        
;;;683      if(status == FLASH_COMPLETE)
000012  2804              CMP      r0,#4
000014  d127              BNE      |L5.102|
;;;684      {
;;;685        /* Clear the FTDW bit */
;;;686        FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
000016  4815              LDR      r0,|L5.108|
000018  6801              LDR      r1,[r0,#0]
00001a  f4217180          BIC      r1,r1,#0x100
00001e  6001              STR      r1,[r0,#0]
;;;687    
;;;688    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;689        if(Data != (uint16_t)0x0000) 
000020  b126              CBZ      r6,|L5.44|
;;;690        {
;;;691          /* If the previous operation is completed, proceed to write the new data */
;;;692          *(__IO uint16_t *)Address = Data;
000022  8026              STRH     r6,[r4,#0]
;;;693      
;;;694          /* Wait for last operation to be completed */
;;;695          status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       FLASH_WaitForLastOperation
00002a  e012              B        |L5.82|
                  |L5.44|
;;;696        }
;;;697        else
;;;698        {
;;;699          if((Address & 0x3) != 0x3)
00002c  43e0              MVNS     r0,r4
00002e  0780              LSLS     r0,r0,#30
000030  d011              BEQ      |L5.86|
;;;700          {
;;;701            tmpaddr = Address & 0xFFFFFFFC;
000032  f0240603          BIC      r6,r4,#3
;;;702            tmp = * (__IO uint32_t *) tmpaddr;
000036  6835              LDR      r5,[r6,#0]
;;;703            tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
000038  07a0              LSLS     r0,r4,#30
00003a  0ec1              LSRS     r1,r0,#27
00003c  f64f70ff          MOV      r0,#0xffff
000040  4088              LSLS     r0,r0,r1
;;;704            tmp &= ~tmpaddr;        
000042  4385              BICS     r5,r5,r0
000044  4630              MOV      r0,r6
;;;705            status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
000046  f7fffffe          BL       DATA_EEPROM_EraseWord
;;;706            status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
00004a  4629              MOV      r1,r5
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       DATA_EEPROM_FastProgramWord
                  |L5.82|
000052  4605              MOV      r5,r0
000054  e007              B        |L5.102|
                  |L5.86|
;;;707          }
;;;708          else
;;;709          {
;;;710            DATA_EEPROM_FastProgramByte(Address, 0x00);
000056  2100              MOVS     r1,#0
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       DATA_EEPROM_FastProgramByte
;;;711            DATA_EEPROM_FastProgramByte(Address + 1, 0x00);
00005e  2100              MOVS     r1,#0
000060  1c60              ADDS     r0,r4,#1
000062  f7fffffe          BL       DATA_EEPROM_FastProgramByte
                  |L5.102|
;;;712          }
;;;713        }
;;;714    #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP)
;;;715        /* If the previous operation is completed, proceed to write the new data */
;;;716        *(__IO uint16_t *)Address = Data;
;;;717      
;;;718        /* Wait for last operation to be completed */
;;;719        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
;;;720    #endif
;;;721      }
;;;722      /* Return the Write Status */
;;;723      return status;
000066  4628              MOV      r0,r5
;;;724    }
000068  bdf0              POP      {r4-r7,pc}
;;;725    
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      0x40023c04

                          AREA ||i.DATA_EEPROM_FastProgramWord||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_FastProgramWord PROC
;;;738      */
;;;739    FLASH_Status DATA_EEPROM_FastProgramWord(uint32_t Address, uint32_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;740    {
000002  4605              MOV      r5,r0
;;;741      FLASH_Status status = FLASH_COMPLETE;
;;;742    
;;;743      /* Check the parameters */
;;;744      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;745      
;;;746      /* Wait for last operation to be completed */
;;;747      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460c              MOV      r4,r1                 ;740
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;748      
;;;749      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d10a              BNE      |L6.42|
;;;750      {
;;;751        /* Clear the FTDW bit */
;;;752        FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
000014  4805              LDR      r0,|L6.44|
000016  6801              LDR      r1,[r0,#0]
000018  f4217180          BIC      r1,r1,#0x100
00001c  6001              STR      r1,[r0,#0]
;;;753      
;;;754        /* If the previous operation is completed, proceed to program the new data */    
;;;755        *(__IO uint32_t *)Address = Data;
00001e  602c              STR      r4,[r5,#0]
;;;756        
;;;757        /* Wait for last operation to be completed */
;;;758        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);       
000020  4630              MOV      r0,r6
000022  e8bd4070          POP      {r4-r6,lr}
000026  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L6.42|
;;;759      }
;;;760      /* Return the Write Status */
;;;761      return status;
;;;762    }
00002a  bd70              POP      {r4-r6,pc}
;;;763    
                          ENDP

                  |L6.44|
                          DCD      0x40023c04

                          AREA ||i.DATA_EEPROM_FixedTimeProgramCmd||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_FixedTimeProgramCmd PROC
;;;481      */
;;;482    void DATA_EEPROM_FixedTimeProgramCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L7.24|
;;;483    {
;;;484      /* Check the parameters */
;;;485      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;486      
;;;487      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;488      {
;;;489        FLASH->PECR |= (uint32_t)FLASH_PECR_FTDW;
;;;490      }
;;;491      else
;;;492      {
;;;493        FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L7.14|
000008  f4407080          ORR      r0,r0,#0x100          ;489
00000c  e001              B        |L7.18|
                  |L7.14|
00000e  f4207080          BIC      r0,r0,#0x100
                  |L7.18|
000012  6008              STR      r0,[r1,#0]            ;489
;;;494      }
;;;495    }
000014  4770              BX       lr
;;;496    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40023c04

                          AREA ||i.DATA_EEPROM_Lock||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_Lock PROC
;;;469      */
;;;470    void DATA_EEPROM_Lock(void)
000000  4802              LDR      r0,|L8.12|
;;;471    {
;;;472      /* Set the PELOCK Bit to lock the data memory and FLASH_PECR register access */
;;;473      FLASH->PECR |= FLASH_PECR_PELOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;474    }
00000a  4770              BX       lr
;;;475    
                          ENDP

                  |L8.12|
                          DCD      0x40023c04

                          AREA ||i.DATA_EEPROM_ProgramByte||, CODE, READONLY, ALIGN=1

                  DATA_EEPROM_ProgramByte PROC
;;;777      */
;;;778    FLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;779    {
000002  4605              MOV      r5,r0
;;;780      FLASH_Status status = FLASH_COMPLETE;
;;;781    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;782      uint32_t tmp = 0, tmpaddr = 0;
;;;783    #endif
;;;784      
;;;785      /* Check the parameters */
;;;786      assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
;;;787    
;;;788      /* Wait for last operation to be completed */
;;;789      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460c              MOV      r4,r1                 ;779
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;790      
;;;791      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d117              BNE      |L9.68|
;;;792      {
;;;793    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;794        if(Data != (uint8_t) 0x00)
000014  b12c              CBZ      r4,|L9.34|
;;;795        {  
;;;796          *(__IO uint8_t *)Address = Data;
000016  702c              STRB     r4,[r5,#0]
;;;797        
;;;798          /* Wait for last operation to be completed */
;;;799          status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000018  4630              MOV      r0,r6
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L9.34|
;;;800    
;;;801        }
;;;802        else
;;;803        {
;;;804          tmpaddr = Address & 0xFFFFFFFC;
000022  f0250603          BIC      r6,r5,#3
;;;805          tmp = * (__IO uint32_t *) tmpaddr;
000026  6834              LDR      r4,[r6,#0]
;;;806          tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
000028  07a8              LSLS     r0,r5,#30
00002a  0ec1              LSRS     r1,r0,#27
00002c  20ff              MOVS     r0,#0xff
00002e  4088              LSLS     r0,r0,r1
;;;807          tmp &= ~tmpaddr;        
000030  4384              BICS     r4,r4,r0
000032  4630              MOV      r0,r6
;;;808          status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
000034  f7fffffe          BL       DATA_EEPROM_EraseWord
;;;809          status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
000038  4621              MOV      r1,r4
00003a  4630              MOV      r0,r6
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      DATA_EEPROM_FastProgramWord
                  |L9.68|
;;;810        }
;;;811    #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP)
;;;812        *(__IO uint8_t *)Address = Data;
;;;813        
;;;814        /* Wait for last operation to be completed */
;;;815        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
;;;816    #endif
;;;817      }
;;;818      /* Return the Write Status */
;;;819      return status;
;;;820    }
000044  bd70              POP      {r4-r6,pc}
;;;821    
                          ENDP


                          AREA ||i.DATA_EEPROM_ProgramHalfWord||, CODE, READONLY, ALIGN=1

                  DATA_EEPROM_ProgramHalfWord PROC
;;;835      */
;;;836    FLASH_Status DATA_EEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;837    {
000002  4604              MOV      r4,r0
;;;838      FLASH_Status status = FLASH_COMPLETE;
;;;839    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;840      uint32_t tmp = 0, tmpaddr = 0;
;;;841    #endif
;;;842      
;;;843      /* Check the parameters */
;;;844      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;845    
;;;846      /* Wait for last operation to be completed */
;;;847      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4700          MOV      r7,#0x8000
000008  460e              MOV      r6,r1                 ;837
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
000010  4605              MOV      r5,r0
;;;848      
;;;849      if(status == FLASH_COMPLETE)
000012  2804              CMP      r0,#4
000014  d122              BNE      |L10.92|
;;;850      {
;;;851    #if !defined (STM32L1XX_HD) && !defined (STM32L1XX_MDP)
;;;852        if(Data != (uint16_t)0x0000)
000016  b126              CBZ      r6,|L10.34|
;;;853        {
;;;854          *(__IO uint16_t *)Address = Data;
000018  8026              STRH     r6,[r4,#0]
;;;855       
;;;856          /* Wait for last operation to be completed */
;;;857          status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       FLASH_WaitForLastOperation
000020  e012              B        |L10.72|
                  |L10.34|
;;;858        }
;;;859        else
;;;860        {
;;;861          if((Address & 0x3) != 0x3)
000022  43e0              MVNS     r0,r4
000024  0780              LSLS     r0,r0,#30
000026  d011              BEQ      |L10.76|
;;;862          {
;;;863            tmpaddr = Address & 0xFFFFFFFC;
000028  f0240603          BIC      r6,r4,#3
;;;864            tmp = * (__IO uint32_t *) tmpaddr;
00002c  6835              LDR      r5,[r6,#0]
;;;865            tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
00002e  07a0              LSLS     r0,r4,#30
000030  0ec1              LSRS     r1,r0,#27
000032  f64f70ff          MOV      r0,#0xffff
000036  4088              LSLS     r0,r0,r1
;;;866            tmp &= ~tmpaddr;          
000038  4385              BICS     r5,r5,r0
00003a  4630              MOV      r0,r6
;;;867            status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
00003c  f7fffffe          BL       DATA_EEPROM_EraseWord
;;;868            status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
000040  4629              MOV      r1,r5
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       DATA_EEPROM_FastProgramWord
                  |L10.72|
000048  4605              MOV      r5,r0
00004a  e007              B        |L10.92|
                  |L10.76|
;;;869          }
;;;870          else
;;;871          {
;;;872            DATA_EEPROM_FastProgramByte(Address, 0x00);
00004c  2100              MOVS     r1,#0
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       DATA_EEPROM_FastProgramByte
;;;873            DATA_EEPROM_FastProgramByte(Address + 1, 0x00);
000054  2100              MOVS     r1,#0
000056  1c60              ADDS     r0,r4,#1
000058  f7fffffe          BL       DATA_EEPROM_FastProgramByte
                  |L10.92|
;;;874          }
;;;875        }
;;;876    #elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP)
;;;877        *(__IO uint16_t *)Address = Data;
;;;878       
;;;879        /* Wait for last operation to be completed */
;;;880        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
;;;881    #endif
;;;882      }
;;;883      /* Return the Write Status */
;;;884      return status;
00005c  4628              MOV      r0,r5
;;;885    }
00005e  bdf0              POP      {r4-r7,pc}
;;;886    
                          ENDP


                          AREA ||i.DATA_EEPROM_ProgramWord||, CODE, READONLY, ALIGN=1

                  DATA_EEPROM_ProgramWord PROC
;;;900      */
;;;901    FLASH_Status DATA_EEPROM_ProgramWord(uint32_t Address, uint32_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;902    {
000002  4605              MOV      r5,r0
;;;903      FLASH_Status status = FLASH_COMPLETE;
;;;904      
;;;905      /* Check the parameters */
;;;906      assert_param(IS_FLASH_DATA_ADDRESS(Address));
;;;907      
;;;908      /* Wait for last operation to be completed */
;;;909      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460c              MOV      r4,r1                 ;902
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;910      
;;;911      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d105              BNE      |L11.32|
;;;912      {
;;;913        *(__IO uint32_t *)Address = Data;
000014  602c              STR      r4,[r5,#0]
;;;914    
;;;915        /* Wait for last operation to be completed */
;;;916        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000016  4630              MOV      r0,r6
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L11.32|
;;;917      }
;;;918      /* Return the Write Status */
;;;919      return status;
;;;920    }
000020  bd70              POP      {r4-r6,pc}
;;;921    
                          ENDP


                          AREA ||i.DATA_EEPROM_Unlock||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_Unlock PROC
;;;454      */
;;;455    void DATA_EEPROM_Unlock(void)
000000  4805              LDR      r0,|L12.24|
;;;456    {
;;;457      if((FLASH->PECR & FLASH_PECR_PELOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d005              BEQ      |L12.20|
;;;458      {  
;;;459        /* Unlocking the Data memory and FLASH_PECR register access*/
;;;460        FLASH->PEKEYR = FLASH_PEKEY1;
000008  4803              LDR      r0,|L12.24|
00000a  4904              LDR      r1,|L12.28|
00000c  3008              ADDS     r0,r0,#8
00000e  6001              STR      r1,[r0,#0]
;;;461        FLASH->PEKEYR = FLASH_PEKEY2;
000010  4903              LDR      r1,|L12.32|
000012  6001              STR      r1,[r0,#0]
                  |L12.20|
;;;462      }
;;;463    }
000014  4770              BX       lr
;;;464    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40023c04
                  |L12.28|
                          DCD      0x89abcdef
                  |L12.32|
                          DCD      0x02030405

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1561     */
;;;1562   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L13.8|
;;;1563   {
;;;1564     /* Check the parameters */
;;;1565     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;1566     
;;;1567     /* Clear the flags */
;;;1568     FLASH->SR = FLASH_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;1569   }
000004  4770              BX       lr
;;;1570   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40023c18

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;345      */
;;;346    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;347    {
000002  4605              MOV      r5,r0
;;;348      FLASH_Status status = FLASH_COMPLETE;
;;;349    
;;;350      /* Check the parameters */
;;;351      assert_param(IS_FLASH_PROGRAM_ADDRESS(Page_Address));
;;;352     
;;;353      /* Wait for last operation to be completed */
;;;354      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;355      
;;;356      if(status == FLASH_COMPLETE)
00000e  2804              CMP      r0,#4
000010  d115              BNE      |L14.62|
;;;357      {
;;;358        /* If the previous operation is completed, proceed to erase the page */
;;;359    
;;;360        /* Set the ERASE bit */
;;;361        FLASH->PECR |= FLASH_PECR_ERASE;
000012  4c0b              LDR      r4,|L14.64|
000014  6820              LDR      r0,[r4,#0]
000016  f4407000          ORR      r0,r0,#0x200
00001a  6020              STR      r0,[r4,#0]
;;;362    
;;;363        /* Set PROG bit */
;;;364        FLASH->PECR |= FLASH_PECR_PROG;
00001c  6820              LDR      r0,[r4,#0]
00001e  f0400008          ORR      r0,r0,#8
000022  6020              STR      r0,[r4,#0]
;;;365      
;;;366        /* Write 00000000h to the first word of the program page to erase */
;;;367        *(__IO uint32_t *)Page_Address = 0x00000000;
000024  2000              MOVS     r0,#0
000026  6028              STR      r0,[r5,#0]
;;;368     
;;;369        /* Wait for last operation to be completed */
;;;370        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;371    
;;;372        /* If the erase operation is completed, disable the ERASE and PROG bits */
;;;373        FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
00002e  6821              LDR      r1,[r4,#0]
000030  f0210108          BIC      r1,r1,#8
000034  6021              STR      r1,[r4,#0]
;;;374        FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);   
000036  6821              LDR      r1,[r4,#0]
000038  f4217100          BIC      r1,r1,#0x200
00003c  6021              STR      r1,[r4,#0]
                  |L14.62|
;;;375      }     
;;;376      /* Return the Erase Status */
;;;377      return status;
;;;378    }
00003e  bd70              POP      {r4-r6,pc}
;;;379    
                          ENDP

                  |L14.64|
                          DCD      0x40023c04

                          AREA ||i.FLASH_FastProgramWord||, CODE, READONLY, ALIGN=1

                  FLASH_FastProgramWord PROC
;;;390      */
;;;391    FLASH_Status FLASH_FastProgramWord(uint32_t Address, uint32_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;392    {
000002  4605              MOV      r5,r0
;;;393      FLASH_Status status = FLASH_COMPLETE;
;;;394    
;;;395      /* Check the parameters */
;;;396      assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
;;;397      
;;;398      /* Wait for last operation to be completed */
;;;399      status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460c              MOV      r4,r1                 ;392
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;400      
;;;401      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d105              BNE      |L15.32|
;;;402      {
;;;403        /* If the previous operation is completed, proceed to program the new  word */  
;;;404        *(__IO uint32_t *)Address = Data;
000014  602c              STR      r4,[r5,#0]
;;;405        
;;;406        /* Wait for last operation to be completed */
;;;407        status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);       
000016  4630              MOV      r0,r6
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L15.32|
;;;408      }
;;;409      /* Return the Write Status */
;;;410      return status;
;;;411    }
000020  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP


                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1530     */
;;;1531   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4a03              LDR      r2,|L16.16|
;;;1532   {
000002  4601              MOV      r1,r0
;;;1533     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1534   
;;;1535     /* Check the parameters */
;;;1536     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;1537   
;;;1538     if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L16.14|
;;;1539     {
;;;1540       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L16.14|
;;;1541     }
;;;1542     else
;;;1543     {
;;;1544       bitstatus = RESET;
;;;1545     }
;;;1546     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1547     return bitstatus; 
;;;1548   }
00000e  4770              BX       lr
;;;1549   
                          ENDP

                  |L16.16|
                          DCD      0x40023c18

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1576     */
;;;1577   FLASH_Status FLASH_GetStatus(void)
000000  4908              LDR      r1,|L17.36|
;;;1578   {
;;;1579     FLASH_Status FLASHstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;1580     
;;;1581     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  680a              LDR      r2,[r1,#0]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L17.14|
;;;1582     {
;;;1583       FLASHstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1584     }
;;;1585     else 
;;;1586     {  
;;;1587       if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
;;;1588       { 
;;;1589         FLASHstatus = FLASH_ERROR_WRP;
;;;1590       }
;;;1591       else 
;;;1592       {
;;;1593         if((FLASH->SR & (uint32_t)0x1E00) != (uint32_t)0x00)
;;;1594         {
;;;1595           FLASHstatus = FLASH_ERROR_PROGRAM; 
;;;1596         }
;;;1597         else
;;;1598         {
;;;1599           FLASHstatus = FLASH_COMPLETE;
;;;1600         }
;;;1601       }
;;;1602     }
;;;1603     /* Return the FLASH Status */
;;;1604     return FLASHstatus;
;;;1605   }
00000c  4770              BX       lr
                  |L17.14|
00000e  680a              LDR      r2,[r1,#0]            ;1587
000010  05d2              LSLS     r2,r2,#23             ;1587
000012  d501              BPL      |L17.24|
000014  2002              MOVS     r0,#2                 ;1589
                  |L17.22|
000016  4770              BX       lr
                  |L17.24|
000018  6809              LDR      r1,[r1,#0]            ;1593
00001a  f4115ff0          TST      r1,#0x1e00            ;1593
00001e  d0fa              BEQ      |L17.22|
000020  2003              MOVS     r0,#3                 ;1595
000022  4770              BX       lr
;;;1606   
                          ENDP

                  |L17.36|
                          DCD      0x40023c18

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1497     */
;;;1498   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L18.20|
;;;1499   {
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1502     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1503     
;;;1504     if(NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1505     {
;;;1506       /* Enable the interrupt sources */
;;;1507       FLASH->PECR |= FLASH_IT;
;;;1508     }
;;;1509     else
;;;1510     {
;;;1511       /* Disable the interrupt sources */
;;;1512       FLASH->PECR &= ~(uint32_t)FLASH_IT;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L18.12|
000008  4301              ORRS     r1,r1,r0              ;1507
00000a  e000              B        |L18.14|
                  |L18.12|
00000c  4381              BICS     r1,r1,r0
                  |L18.14|
00000e  6011              STR      r1,[r2,#0]            ;1507
;;;1513     }
;;;1514   }
000010  4770              BX       lr
;;;1515   
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40023c04

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;327      */
;;;328    void FLASH_Lock(void)
000000  4802              LDR      r0,|L19.12|
;;;329    {
;;;330      /* Set the PRGLOCK Bit to lock the program memory access */
;;;331      FLASH->PECR |= FLASH_PECR_PRGLOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0410102          ORR      r1,r1,#2
000008  6001              STR      r1,[r0,#0]
;;;332    }
00000a  4770              BX       lr
;;;333    
                          ENDP

                  |L19.12|
                          DCD      0x40023c04

                          AREA ||i.FLASH_OB_BORConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BORConfig PROC
;;;1310     */
;;;1311   FLASH_Status FLASH_OB_BORConfig(uint8_t OB_BOR)
000000  b530              PUSH     {r4,r5,lr}
;;;1312   {
;;;1313     FLASH_Status status = FLASH_COMPLETE;
;;;1314     uint32_t tmp = 0, tmp1 = 0;
;;;1315   
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_OB_BOR_LEVEL(OB_BOR));
;;;1318   
;;;1319     /* Get the User Option byte register */
;;;1320     tmp1 = (FLASH->OBR & 0x00F00000) >> 16;
000002  490b              LDR      r1,|L20.48|
000004  6809              LDR      r1,[r1,#0]
;;;1321        
;;;1322     /* Calculate the option byte to write */
;;;1323     tmp = (uint32_t)~(OB_BOR | tmp1)<<16;
;;;1324     tmp |= (OB_BOR | tmp1);
;;;1325       
;;;1326     /* Wait for last operation to be completed */
;;;1327     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
;;;1328     
;;;1329     if(status == FLASH_COMPLETE)
;;;1330     {  
;;;1331       /* Write the BOR Option Byte */            
;;;1332       OB->USER = tmp; 
;;;1333     }
;;;1334     
;;;1335     /* Wait for last operation to be completed */
;;;1336     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
;;;1337           
;;;1338     /* Return the Option Byte program Status */
;;;1339     return status;
;;;1340   }
000006  22f0              MOVS     r2,#0xf0
000008  ea024111          AND      r1,r2,r1,LSR #16
00000c  4308              ORRS     r0,r0,r1              ;1323
00000e  43c1              MVNS     r1,r0                 ;1323
000010  ea404401          ORR      r4,r0,r1,LSL #16      ;1324
000014  f44f4500          MOV      r5,#0x8000            ;1327
000018  4628              MOV      r0,r5                 ;1327
00001a  f7fffffe          BL       FLASH_WaitForLastOperation
00001e  2804              CMP      r0,#4                 ;1329
000020  d101              BNE      |L20.38|
000022  4804              LDR      r0,|L20.52|
000024  6044              STR      r4,[r0,#4]            ;1332
                  |L20.38|
000026  4628              MOV      r0,r5                 ;1336
000028  e8bd4030          POP      {r4,r5,lr}            ;1336
00002c  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;1341   
                          ENDP

                  |L20.48|
                          DCD      0x40023c1c
                  |L20.52|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_OB_BootConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BootConfig PROC
;;;1363     */
;;;1364   FLASH_Status FLASH_OB_BootConfig(uint8_t OB_BOOT)
000000  b530              PUSH     {r4,r5,lr}
;;;1365   {
;;;1366     FLASH_Status status = FLASH_COMPLETE; 
;;;1367     uint32_t tmp = 0, tmp1 = 0;
;;;1368   
;;;1369     /* Check the parameters */
;;;1370     assert_param(IS_OB_BOOT_BANK(OB_BOOT));
;;;1371   
;;;1372     /* Get the User Option byte register */
;;;1373     tmp1 = (FLASH->OBR & 0x007F0000) >> 16;
000002  490b              LDR      r1,|L21.48|
000004  6809              LDR      r1,[r1,#0]
;;;1374        
;;;1375     /* Calculate the option byte to write */
;;;1376     tmp = (uint32_t)~(OB_BOOT | tmp1)<<16;
;;;1377     tmp |= (OB_BOOT | tmp1);
;;;1378       
;;;1379     /* Wait for last operation to be completed */
;;;1380     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000006  f44f4500          MOV      r5,#0x8000
00000a  f3c14106          UBFX     r1,r1,#16,#7          ;1373
00000e  4308              ORRS     r0,r0,r1              ;1376
000010  43c1              MVNS     r1,r0                 ;1376
000012  ea404401          ORR      r4,r0,r1,LSL #16      ;1377
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1381     
;;;1382     if(status == FLASH_COMPLETE)
00001c  2804              CMP      r0,#4
00001e  d101              BNE      |L21.36|
;;;1383     {  
;;;1384       /* Write the BOOT Option Byte */            
;;;1385       OB->USER = tmp; 
000020  4804              LDR      r0,|L21.52|
000022  6044              STR      r4,[r0,#4]
                  |L21.36|
;;;1386     }
;;;1387     
;;;1388     /* Wait for last operation to be completed */
;;;1389     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000024  4628              MOV      r0,r5
000026  e8bd4030          POP      {r4,r5,lr}
00002a  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;1390          
;;;1391     /* Return the Option Byte program Status */
;;;1392     return status;
;;;1393   }
;;;1394   
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      0x40023c1c
                  |L21.52|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;1466     */
;;;1467   uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L22.12|
;;;1468   {
;;;1469     /* Return the BOR level */
;;;1470     return (uint8_t)((FLASH->OBR & (uint32_t)0x000F0000) >> 16);
000002  6800              LDR      r0,[r0,#0]
000004  f3c04003          UBFX     r0,r0,#16,#4
;;;1471   }
000008  4770              BX       lr
;;;1472   
                          ENDP

00000a  0000              DCW      0x0000
                  |L22.12|
                          DCD      0x40023c1c

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1446     */
;;;1447   FlagStatus FLASH_OB_GetRDP(void)
000000  4903              LDR      r1,|L23.16|
;;;1448   {
;;;1449     FlagStatus readstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1450     
;;;1451     if ((uint8_t)(FLASH->OBR) != (uint8_t)OB_RDP_Level_0)
000004  6809              LDR      r1,[r1,#0]
000006  b2c9              UXTB     r1,r1
000008  29aa              CMP      r1,#0xaa
00000a  d000              BEQ      |L23.14|
;;;1452     {
;;;1453       readstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L23.14|
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       readstatus = RESET;
;;;1458     }
;;;1459     return readstatus;
;;;1460   }
00000e  4770              BX       lr
;;;1461   
                          ENDP

                  |L23.16|
                          DCD      0x40023c1c

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1399     */
;;;1400   uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L24.12|
;;;1401   {
;;;1402     /* Return the User Option Byte */
;;;1403     return (uint8_t)(FLASH->OBR >> 20);
000002  6800              LDR      r0,[r0,#0]
000004  f3c05007          UBFX     r0,r0,#20,#8
;;;1404   }
000008  4770              BX       lr
;;;1405   
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      0x40023c1c

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1410     */
;;;1411   uint32_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L25.8|
;;;1412   {
;;;1413     /* Return the FLASH write protection Register value */
;;;1414     return (uint32_t)(FLASH->WRPR);
000002  6800              LDR      r0,[r0,#0]
;;;1415   }
000004  4770              BX       lr
;;;1416   
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x40023c20

                          AREA ||i.FLASH_OB_GetWRP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP1 PROC
;;;1423     */
;;;1424   uint32_t FLASH_OB_GetWRP1(void)
000000  4801              LDR      r0,|L26.8|
;;;1425   {
;;;1426     /* Return the FLASH write protection Register value */
;;;1427     return (uint32_t)(FLASH->WRPR1);
000002  6800              LDR      r0,[r0,#0]
;;;1428   }
000004  4770              BX       lr
;;;1429   
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x40023c80

                          AREA ||i.FLASH_OB_GetWRP2||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP2 PROC
;;;1435     */
;;;1436   uint32_t FLASH_OB_GetWRP2(void)
000000  4801              LDR      r0,|L27.8|
;;;1437   {
;;;1438     /* Return the FLASH write protection Register value */
;;;1439     return (uint32_t)(FLASH->WRPR2);
000002  6800              LDR      r0,[r0,#0]
;;;1440   }
000004  4770              BX       lr
;;;1441   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40023c84

                          AREA ||i.FLASH_OB_Launch||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Launch PROC
;;;1005     */
;;;1006   void FLASH_OB_Launch(void)
000000  4802              LDR      r0,|L28.12|
;;;1007   {
;;;1008     /* Set the OBL_Launch bit to lauch the option byte loading */
;;;1009     FLASH->PECR |= FLASH_PECR_OBL_LAUNCH;
000002  6801              LDR      r1,[r0,#0]
000004  f4412180          ORR      r1,r1,#0x40000
000008  6001              STR      r1,[r0,#0]
;;;1010   }
00000a  4770              BX       lr
;;;1011   
                          ENDP

                  |L28.12|
                          DCD      0x40023c04

                          AREA ||i.FLASH_OB_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Lock PROC
;;;994      */
;;;995    void FLASH_OB_Lock(void)
000000  4802              LDR      r0,|L29.12|
;;;996    {
;;;997      /* Set the OPTLOCK Bit to lock the option bytes block access */
;;;998      FLASH->PECR |= FLASH_PECR_OPTLOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;999    }
00000a  4770              BX       lr
;;;1000   
                          ENDP

                  |L29.12|
                          DCD      0x40023c04

                          AREA ||i.FLASH_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDPConfig PROC
;;;1211     */
;;;1212   FLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP)
000000  b530              PUSH     {r4,r5,lr}
;;;1213   {
000002  4604              MOV      r4,r0
;;;1214     FLASH_Status status = FLASH_COMPLETE;
;;;1215     uint8_t tmp1 = 0;
;;;1216     uint32_t tmp2 = 0;
;;;1217     
;;;1218     /* Check the parameters */
;;;1219     assert_param(IS_OB_RDP(OB_RDP));
;;;1220     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4500          MOV      r5,#0x8000
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1221     
;;;1222     /* calculate the option byte to write */
;;;1223     tmp1 = (uint8_t)(~(OB_RDP ));
00000e  43e1              MVNS     r1,r4
000010  b2c9              UXTB     r1,r1
;;;1224     tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)OB_RDP));
000012  ea444101          ORR      r1,r4,r1,LSL #16
;;;1225     
;;;1226     if(status == FLASH_COMPLETE)
000016  2804              CMP      r0,#4
000018  d101              BNE      |L30.30|
;;;1227     {         
;;;1228      /* program read protection level */
;;;1229       OB->RDP = tmp2;
00001a  4803              LDR      r0,|L30.40|
00001c  6001              STR      r1,[r0,#0]
                  |L30.30|
;;;1230     }
;;;1231     
;;;1232     /* Wait for last operation to be completed */
;;;1233       status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00001e  4628              MOV      r0,r5
000020  e8bd4030          POP      {r4,r5,lr}
000024  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;1234        
;;;1235     /* Return the Read protection operation Status */
;;;1236     return status;            
;;;1237   }
;;;1238   
                          ENDP

                  |L30.40|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Unlock PROC
;;;976      */
;;;977    void FLASH_OB_Unlock(void)
000000  4806              LDR      r0,|L31.28|
;;;978    {
000002  b500              PUSH     {lr}
;;;979      if((FLASH->PECR & FLASH_PECR_OPTLOCK) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  0740              LSLS     r0,r0,#29
000008  d507              BPL      |L31.26|
;;;980      {
;;;981        /* Unlocking the data memory and FLASH_PECR register access */
;;;982        DATA_EEPROM_Unlock();
00000a  f7fffffe          BL       DATA_EEPROM_Unlock
;;;983      
;;;984        /* Unlocking the option bytes block access */
;;;985        FLASH->OPTKEYR = FLASH_OPTKEY1;
00000e  4803              LDR      r0,|L31.28|
000010  4903              LDR      r1,|L31.32|
000012  3010              ADDS     r0,r0,#0x10
000014  6001              STR      r1,[r0,#0]
;;;986        FLASH->OPTKEYR = FLASH_OPTKEY2;
000016  4903              LDR      r1,|L31.36|
000018  6001              STR      r1,[r0,#0]
                  |L31.26|
;;;987      }
;;;988    }
00001a  bd00              POP      {pc}
;;;989    
                          ENDP

                  |L31.28|
                          DCD      0x40023c04
                  |L31.32|
                          DCD      0xfbead9c8
                  |L31.36|
                          DCD      0x24252627

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;1259     */
;;;1260   FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
000000  b530              PUSH     {r4,r5,lr}
;;;1261   {
;;;1262     FLASH_Status status = FLASH_COMPLETE; 
;;;1263     uint32_t tmp = 0, tmp1 = 0;
;;;1264   
;;;1265     /* Check the parameters */
;;;1266     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1267     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1268     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1269   
;;;1270     /* Get the User Option byte register */
;;;1271     tmp1 = (FLASH->OBR & 0x000F0000) >> 16;
000002  4b0c              LDR      r3,|L32.52|
000004  681b              LDR      r3,[r3,#0]
;;;1272       
;;;1273     /* Calculate the user option byte to write */ 
;;;1274     tmp = (uint32_t)(((uint32_t)~((uint32_t)((uint32_t)(OB_IWDG) | (uint32_t)(OB_STOP) | (uint32_t)(OB_STDBY) | tmp1))) << ((uint32_t)0x10));
000006  4308              ORRS     r0,r0,r1
000008  f3c34303          UBFX     r3,r3,#16,#4          ;1271
00000c  4310              ORRS     r0,r0,r2
00000e  ea400403          ORR      r4,r0,r3
000012  43e0              MVNS     r0,r4
;;;1275     tmp |= ((uint32_t)(OB_IWDG) | ((uint32_t)OB_STOP) | (uint32_t)(OB_STDBY) | tmp1);
000014  ea444400          ORR      r4,r4,r0,LSL #16
;;;1276     
;;;1277     /* Wait for last operation to be completed */
;;;1278     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000018  f44f4500          MOV      r5,#0x8000
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1279     
;;;1280     if(status == FLASH_COMPLETE)
000022  2804              CMP      r0,#4
000024  d101              BNE      |L32.42|
;;;1281     {  
;;;1282       /* Write the User Option Byte */              
;;;1283       OB->USER = tmp; 
000026  4804              LDR      r0,|L32.56|
000028  6044              STR      r4,[r0,#4]
                  |L32.42|
;;;1284     }
;;;1285     
;;;1286     /* Wait for last operation to be completed */
;;;1287       status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00002a  4628              MOV      r0,r5
00002c  e8bd4030          POP      {r4,r5,lr}
000030  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;1288          
;;;1289     /* Return the Option Byte program Status */
;;;1290     return status;
;;;1291   }
;;;1292   
                          ENDP

                  |L32.52|
                          DCD      0x40023c1c
                  |L32.56|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_OB_WRP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRP1Config PROC
;;;1089     */
;;;1090   FLASH_Status FLASH_OB_WRP1Config(uint32_t OB_WRP1, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1091   {
000002  4604              MOV      r4,r0
;;;1092     uint32_t WRP45_Data = 0, WRP67_Data = 0;
;;;1093     
;;;1094     FLASH_Status status = FLASH_COMPLETE;
;;;1095     uint32_t tmp1 = 0, tmp2 = 0;
;;;1096     
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_OB_WRP(OB_WRP1));
;;;1099     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1100        
;;;1101     /* Wait for last operation to be completed */
;;;1102     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460d              MOV      r5,r1                 ;1091
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1103    
;;;1104     if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d11c              BNE      |L33.78|
;;;1105     {
;;;1106       if (NewState != DISABLE)
;;;1107       {
;;;1108         WRP45_Data = (uint16_t)(((OB_WRP1 & WRP45_MASK) | OB->WRP45));
000014  4a0e              LDR      r2,|L33.80|
;;;1109         WRP67_Data = (uint16_t)((((OB_WRP1 & WRP67_MASK)>>16 | OB->WRP67))); 
;;;1110         tmp1 = (uint32_t)(~(WRP45_Data) << 16)|(WRP45_Data);
;;;1111         OB->WRP45 = tmp1;
;;;1112         
;;;1113         tmp2 = (uint32_t)(~(WRP67_Data) << 16)|(WRP67_Data);
;;;1114         OB->WRP67 = tmp2;      
;;;1115       }             
;;;1116       
;;;1117       else
;;;1118       {
;;;1119         WRP45_Data = (uint16_t)(~OB_WRP1 & (WRP45_MASK & OB->WRP45));
000016  6910              LDR      r0,[r2,#0x10]
000018  b135              CBZ      r5,|L33.40|
00001a  4320              ORRS     r0,r0,r4              ;1108
00001c  6951              LDR      r1,[r2,#0x14]         ;1109
00001e  b280              UXTH     r0,r0                 ;1108
000020  ea414114          ORR      r1,r1,r4,LSR #16      ;1109
000024  b289              UXTH     r1,r1                 ;1109
000026  e005              B        |L33.52|
                  |L33.40|
000028  43e1              MVNS     r1,r4
00002a  b28b              UXTH     r3,r1
00002c  4018              ANDS     r0,r0,r3
;;;1120         WRP67_Data = (uint16_t)((((~OB_WRP1 & WRP67_MASK)>>16 & OB->WRP67))); 
00002e  6953              LDR      r3,[r2,#0x14]
000030  ea034111          AND      r1,r3,r1,LSR #16
                  |L33.52|
;;;1121   
;;;1122         tmp1 = (uint32_t)((~WRP45_Data) << 16)|(WRP45_Data);
000034  43c3              MVNS     r3,r0
000036  ea404003          ORR      r0,r0,r3,LSL #16
;;;1123         OB->WRP45 = tmp1;
00003a  6110              STR      r0,[r2,#0x10]
;;;1124         
;;;1125         tmp2 = (uint32_t)((~WRP67_Data) << 16)|(WRP67_Data);
00003c  43c8              MVNS     r0,r1
00003e  ea414000          ORR      r0,r1,r0,LSL #16
;;;1126         OB->WRP67 = tmp2;
000042  6150              STR      r0,[r2,#0x14]
;;;1127       }
;;;1128       /* Wait for last operation to be completed */
;;;1129       status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000044  4630              MOV      r0,r6
000046  e8bd4070          POP      {r4-r6,lr}
00004a  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L33.78|
;;;1130     }
;;;1131   
;;;1132     /* Return the write protection operation Status */
;;;1133     return status;      
;;;1134   }
00004e  bd70              POP      {r4-r6,pc}
;;;1135   
                          ENDP

                  |L33.80|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_OB_WRP2Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRP2Config PROC
;;;1151     */
;;;1152   FLASH_Status FLASH_OB_WRP2Config(uint32_t OB_WRP2, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1153   {
000002  4604              MOV      r4,r0
;;;1154     uint32_t WRP89_Data = 0, WRP1011_Data = 0;
;;;1155     
;;;1156     FLASH_Status status = FLASH_COMPLETE;
;;;1157     uint32_t tmp1 = 0, tmp2 = 0;
;;;1158     
;;;1159     /* Check the parameters */
;;;1160     assert_param(IS_OB_WRP(OB_WRP2));
;;;1161     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1162        
;;;1163     /* Wait for last operation to be completed */
;;;1164     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460d              MOV      r5,r1                 ;1153
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1165    
;;;1166     if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d11c              BNE      |L34.78|
;;;1167     {
;;;1168       if (NewState != DISABLE)
;;;1169       {
;;;1170         WRP89_Data = (uint16_t)(((OB_WRP2 & WRP89_MASK) | OB->WRP89));
000014  4a0e              LDR      r2,|L34.80|
;;;1171         WRP1011_Data = (uint16_t)((((OB_WRP2 & WRP1011_MASK)>>16 | OB->WRP1011))); 
;;;1172         tmp1 = (uint32_t)(~(WRP89_Data) << 16)|(WRP89_Data);
;;;1173         OB->WRP89 = tmp1;
;;;1174         
;;;1175         tmp2 = (uint32_t)(~(WRP1011_Data) << 16)|(WRP1011_Data);
;;;1176         OB->WRP1011 = tmp2;      
;;;1177       }             
;;;1178       
;;;1179       else
;;;1180       {
;;;1181         WRP89_Data = (uint16_t)(~OB_WRP2 & (WRP89_MASK & OB->WRP89));
000016  6990              LDR      r0,[r2,#0x18]
000018  b135              CBZ      r5,|L34.40|
00001a  4320              ORRS     r0,r0,r4              ;1170
00001c  69d1              LDR      r1,[r2,#0x1c]         ;1171
00001e  b280              UXTH     r0,r0                 ;1170
000020  ea414114          ORR      r1,r1,r4,LSR #16      ;1171
000024  b289              UXTH     r1,r1                 ;1171
000026  e005              B        |L34.52|
                  |L34.40|
000028  43e1              MVNS     r1,r4
00002a  b28b              UXTH     r3,r1
00002c  4018              ANDS     r0,r0,r3
;;;1182         WRP1011_Data = (uint16_t)((((~OB_WRP2 & WRP1011_MASK)>>16 & OB->WRP1011))); 
00002e  69d3              LDR      r3,[r2,#0x1c]
000030  ea034111          AND      r1,r3,r1,LSR #16
                  |L34.52|
;;;1183   
;;;1184         tmp1 = (uint32_t)((~WRP89_Data) << 16)|(WRP89_Data);
000034  43c3              MVNS     r3,r0
000036  ea404003          ORR      r0,r0,r3,LSL #16
;;;1185         OB->WRP89 = tmp1;
00003a  6190              STR      r0,[r2,#0x18]
;;;1186         
;;;1187         tmp2 = (uint32_t)((~WRP1011_Data) << 16)|(WRP1011_Data);
00003c  43c8              MVNS     r0,r1
00003e  ea414000          ORR      r0,r1,r0,LSL #16
;;;1188         OB->WRP1011 = tmp2;
000042  61d0              STR      r0,[r2,#0x1c]
;;;1189       }
;;;1190       /* Wait for last operation to be completed */
;;;1191       status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000044  4630              MOV      r0,r6
000046  e8bd4070          POP      {r4-r6,lr}
00004a  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L34.78|
;;;1192     }
;;;1193   
;;;1194     /* Return the write protection operation Status */
;;;1195     return status;      
;;;1196   }
00004e  bd70              POP      {r4-r6,pc}
;;;1197   
                          ENDP

                  |L34.80|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_OB_WRPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRPConfig PROC
;;;1026     */
;;;1027   FLASH_Status FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1028   {
000002  4604              MOV      r4,r0
;;;1029     uint32_t WRP01_Data = 0, WRP23_Data = 0;
;;;1030     
;;;1031     FLASH_Status status = FLASH_COMPLETE;
;;;1032     uint32_t tmp1 = 0, tmp2 = 0;
;;;1033     
;;;1034     /* Check the parameters */
;;;1035     assert_param(IS_OB_WRP(OB_WRP));
;;;1036     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1037        
;;;1038     /* Wait for last operation to be completed */
;;;1039     status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000004  f44f4600          MOV      r6,#0x8000
000008  460d              MOV      r5,r1                 ;1028
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1040    
;;;1041     if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d11c              BNE      |L35.78|
;;;1042     {
;;;1043       if (NewState != DISABLE)
;;;1044       {
;;;1045         WRP01_Data = (uint16_t)(((OB_WRP & WRP01_MASK) | OB->WRP01));
000014  4a0e              LDR      r2,|L35.80|
;;;1046         WRP23_Data = (uint16_t)((((OB_WRP & WRP23_MASK)>>16 | OB->WRP23))); 
;;;1047         tmp1 = (uint32_t)(~(WRP01_Data) << 16)|(WRP01_Data);
;;;1048         OB->WRP01 = tmp1;
;;;1049         
;;;1050         tmp2 = (uint32_t)(~(WRP23_Data) << 16)|(WRP23_Data);
;;;1051         OB->WRP23 = tmp2;      
;;;1052       }             
;;;1053       
;;;1054       else
;;;1055       {
;;;1056         WRP01_Data = (uint16_t)(~OB_WRP & (WRP01_MASK & OB->WRP01));
000016  6890              LDR      r0,[r2,#8]
000018  b135              CBZ      r5,|L35.40|
00001a  4320              ORRS     r0,r0,r4              ;1045
00001c  68d1              LDR      r1,[r2,#0xc]          ;1046
00001e  b280              UXTH     r0,r0                 ;1045
000020  ea414114          ORR      r1,r1,r4,LSR #16      ;1046
000024  b289              UXTH     r1,r1                 ;1046
000026  e005              B        |L35.52|
                  |L35.40|
000028  43e1              MVNS     r1,r4
00002a  b28b              UXTH     r3,r1
00002c  4018              ANDS     r0,r0,r3
;;;1057         WRP23_Data = (uint16_t)((((~OB_WRP & WRP23_MASK)>>16 & OB->WRP23))); 
00002e  68d3              LDR      r3,[r2,#0xc]
000030  ea034111          AND      r1,r3,r1,LSR #16
                  |L35.52|
;;;1058   
;;;1059         tmp1 = (uint32_t)((~WRP01_Data) << 16)|(WRP01_Data);
000034  43c3              MVNS     r3,r0
000036  ea404003          ORR      r0,r0,r3,LSL #16
;;;1060         OB->WRP01 = tmp1;
00003a  6090              STR      r0,[r2,#8]
;;;1061         
;;;1062         tmp2 = (uint32_t)((~WRP23_Data) << 16)|(WRP23_Data);
00003c  43c8              MVNS     r0,r1
00003e  ea414000          ORR      r0,r1,r0,LSL #16
;;;1063         OB->WRP23 = tmp2;
000042  60d0              STR      r0,[r2,#0xc]
;;;1064       }
;;;1065       /* Wait for last operation to be completed */
;;;1066       status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000044  4630              MOV      r0,r6
000046  e8bd4070          POP      {r4-r6,lr}
00004a  f7ffbffe          B.W      FLASH_WaitForLastOperation
                  |L35.78|
;;;1067     }
;;;1068   
;;;1069     /* Return the write protection operation Status */
;;;1070     return status;      
;;;1071   }
00004e  bd70              POP      {r4-r6,pc}
;;;1072   
                          ENDP

                  |L35.80|
                          DCD      0x1ff80000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;209      */
;;;210    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L36.24|
;;;211    {
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;214       
;;;215      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;216      {
;;;217        FLASH->ACR |= FLASH_ACR_PRFTEN;
;;;218      }
;;;219      else
;;;220      {
;;;221        FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_PRFTEN));
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L36.14|
000008  f0400002          ORR      r0,r0,#2              ;217
00000c  e001              B        |L36.18|
                  |L36.14|
00000e  f0200002          BIC      r0,r0,#2
                  |L36.18|
000012  6008              STR      r0,[r1,#0]            ;217
;;;222      }
;;;223    }
000014  4770              BX       lr
;;;224    
                          ENDP

000016  0000              DCW      0x0000
                  |L36.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_ReadAccess64Cmd||, CODE, READONLY, ALIGN=2

                  FLASH_ReadAccess64Cmd PROC
;;;236      */
;;;237    void FLASH_ReadAccess64Cmd(FunctionalState NewState)
000000  4905              LDR      r1,|L37.24|
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;241      
;;;242      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;243      {
;;;244        FLASH->ACR |= FLASH_ACR_ACC64;
;;;245      }
;;;246      else
;;;247      {
;;;248        FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_ACC64));
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L37.14|
000008  f0400004          ORR      r0,r0,#4              ;244
00000c  e001              B        |L37.18|
                  |L37.14|
00000e  f0200004          BIC      r0,r0,#4
                  |L37.18|
000012  6008              STR      r0,[r1,#0]            ;244
;;;249      }
;;;250    }
000014  4770              BX       lr
;;;251    
                          ENDP

000016  0000              DCW      0x0000
                  |L37.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_SLEEPPowerDownCmd||, CODE, READONLY, ALIGN=2

                  FLASH_SLEEPPowerDownCmd PROC
;;;258      */
;;;259    void FLASH_SLEEPPowerDownCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L38.24|
;;;260    {
;;;261      /* Check the parameters */
;;;262      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;263      
;;;264      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;265      {
;;;266        /* Set the SLEEP_PD bit to put Flash in power down mode during sleep mode */
;;;267        FLASH->ACR |= FLASH_ACR_SLEEP_PD;
;;;268      }
;;;269      else
;;;270      {
;;;271        /* Clear the SLEEP_PD bit in to put Flash in idle mode during sleep mode */
;;;272        FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_SLEEP_PD));
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L38.14|
000008  f0400008          ORR      r0,r0,#8              ;267
00000c  e001              B        |L38.18|
                  |L38.14|
00000e  f0200008          BIC      r0,r0,#8
                  |L38.18|
000012  6008              STR      r0,[r1,#0]            ;267
;;;273      }
;;;274    }
000014  4770              BX       lr
;;;275    
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;185      */
;;;186    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4a03              LDR      r2,|L39.16|
;;;187    {
;;;188       uint32_t tmpreg = 0;
;;;189      
;;;190      /* Check the parameters */
;;;191      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;192      
;;;193      /* Read the ACR register */
;;;194      tmpreg = FLASH->ACR;  
000002  6811              LDR      r1,[r2,#0]
;;;195      
;;;196      /* Sets the Latency value */
;;;197      tmpreg &= (uint32_t) (~((uint32_t)FLASH_ACR_LATENCY));
000004  f0210101          BIC      r1,r1,#1
;;;198      tmpreg |= FLASH_Latency;
000008  4301              ORRS     r1,r1,r0
;;;199      
;;;200      /* Write the ACR register */
;;;201      FLASH->ACR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;202    }
00000c  4770              BX       lr
;;;203    
                          ENDP

00000e  0000              DCW      0x0000
                  |L39.16|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;309      */
;;;310    void FLASH_Unlock(void)
000000  4806              LDR      r0,|L40.28|
;;;311    {
000002  b500              PUSH     {lr}
;;;312      if((FLASH->PECR & FLASH_PECR_PRGLOCK) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  0780              LSLS     r0,r0,#30
000008  d507              BPL      |L40.26|
;;;313      {
;;;314        /* Unlocking the data memory and FLASH_PECR register access */
;;;315        DATA_EEPROM_Unlock();
00000a  f7fffffe          BL       DATA_EEPROM_Unlock
;;;316      
;;;317        /* Unlocking the program memory access */
;;;318        FLASH->PRGKEYR = FLASH_PRGKEY1;
00000e  4803              LDR      r0,|L40.28|
000010  4903              LDR      r1,|L40.32|
000012  300c              ADDS     r0,r0,#0xc
000014  6001              STR      r1,[r0,#0]
;;;319        FLASH->PRGKEYR = FLASH_PRGKEY2;  
000016  4903              LDR      r1,|L40.36|
000018  6001              STR      r1,[r0,#0]
                  |L40.26|
;;;320      }
;;;321    }
00001a  bd00              POP      {pc}
;;;322    
                          ENDP

                  |L40.28|
                          DCD      0x40023c04
                  |L40.32|
                          DCD      0x8c9daebf
                  |L40.36|
                          DCD      0x13141516

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1613     */
;;;1614   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b508              PUSH     {r3,lr}
;;;1615   { 
000002  4603              MOV      r3,r0
;;;1616     __IO FLASH_Status status = FLASH_COMPLETE;
000004  2004              MOVS     r0,#4
000006  f88d0000          STRB     r0,[sp,#0]
;;;1617      
;;;1618     /* Check for the FLASH Status */
;;;1619     status = FLASH_GetStatus();
00000a  f7fffffe          BL       FLASH_GetStatus
00000e  f88d0000          STRB     r0,[sp,#0]
;;;1620     
;;;1621     /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
;;;1622     while((status == FLASH_BUSY) && (Timeout != 0x00))
000012  e004              B        |L41.30|
                  |L41.20|
;;;1623     {
;;;1624       status = FLASH_GetStatus();
000014  f7fffffe          BL       FLASH_GetStatus
000018  f88d0000          STRB     r0,[sp,#0]
00001c  1e5b              SUBS     r3,r3,#1
                  |L41.30|
00001e  f89d0000          LDRB     r0,[sp,#0]            ;1622
000022  2801              CMP      r0,#1                 ;1622
000024  d001              BEQ      |L41.42|
;;;1625       Timeout--;
;;;1626     }
;;;1627     
;;;1628     if(Timeout == 0x00 )
000026  b113              CBZ      r3,|L41.46|
000028  e004              B        |L41.52|
                  |L41.42|
00002a  2b00              CMP      r3,#0                 ;1622
00002c  d1f2              BNE      |L41.20|
                  |L41.46|
;;;1629     {
;;;1630       status = FLASH_TIMEOUT;
00002e  2005              MOVS     r0,#5
000030  f88d0000          STRB     r0,[sp,#0]
                  |L41.52|
;;;1631     }
;;;1632     /* Return the operation status */
;;;1633     return status;
000034  f89d0000          LDRB     r0,[sp,#0]
;;;1634   }
000038  bd08              POP      {r3,pc}
;;;1635   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32l1xx_flash_c_a2a150d6____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32l1xx_flash_c_a2a150d6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32l1xx_flash_c_a2a150d6____REVSH|
#line 144
|__asm___17_stm32l1xx_flash_c_a2a150d6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
