; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\system_stm32l1xx_1.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\system_stm32l1xx_1.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\system_stm32l1xx_1.crf ..\src\system_stm32l1xx.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=2

                  SetSysClock PROC
;;;311      */
;;;312    static void SetSysClock(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;313    {
;;;314      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
;;;315      
;;;316      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
;;;317      /* Enable HSE */
;;;318      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000004  492c              LDR      r1,|L1.184|
000006  9001              STR      r0,[sp,#4]            ;314
000008  9000              STR      r0,[sp,#0]
00000a  680a              LDR      r2,[r1,#0]
00000c  f4423280          ORR      r2,r2,#0x10000
000010  600a              STR      r2,[r1,#0]
;;;319     
;;;320      /* Wait till HSE is ready and if Time out is reached exit */
;;;321      do
;;;322      {
;;;323        HSEStatus = RCC->CR & RCC_CR_HSERDY;
;;;324        StartUpCounter++;
;;;325      } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000012  f44f63a0          MOV      r3,#0x500
                  |L1.22|
000016  680a              LDR      r2,[r1,#0]            ;323
000018  f4023200          AND      r2,r2,#0x20000        ;323
00001c  9200              STR      r2,[sp,#0]            ;324
00001e  9a01              LDR      r2,[sp,#4]            ;324
000020  1c52              ADDS     r2,r2,#1              ;324
000022  9201              STR      r2,[sp,#4]
000024  9a00              LDR      r2,[sp,#0]
000026  b912              CBNZ     r2,|L1.46|
000028  9a01              LDR      r2,[sp,#4]
00002a  429a              CMP      r2,r3
00002c  d1f3              BNE      |L1.22|
                  |L1.46|
;;;326    
;;;327      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
00002e  680a              LDR      r2,[r1,#0]
000030  0392              LSLS     r2,r2,#14
000032  d53f              BPL      |L1.180|
;;;328      {
;;;329        HSEStatus = (uint32_t)0x01;
000034  2001              MOVS     r0,#1
;;;330      }
;;;331      else
;;;332      {
;;;333        HSEStatus = (uint32_t)0x00;
;;;334      }
;;;335      
;;;336      if (HSEStatus == (uint32_t)0x01)
;;;337      {
;;;338        /* Enable 64-bit access */
;;;339        FLASH->ACR |= FLASH_ACR_ACC64;
000036  9000              STR      r0,[sp,#0]
000038  4820              LDR      r0,|L1.188|
00003a  6802              LDR      r2,[r0,#0]
00003c  f0420204          ORR      r2,r2,#4
000040  6002              STR      r2,[r0,#0]
;;;340        
;;;341        /* Enable Prefetch Buffer */
;;;342        FLASH->ACR |= FLASH_ACR_PRFTEN;
000042  6802              LDR      r2,[r0,#0]
000044  f0420202          ORR      r2,r2,#2
000048  6002              STR      r2,[r0,#0]
;;;343    
;;;344        /* Flash 1 wait state */
;;;345        FLASH->ACR |= FLASH_ACR_LATENCY;
00004a  6802              LDR      r2,[r0,#0]
00004c  f0420201          ORR      r2,r2,#1
000050  6002              STR      r2,[r0,#0]
;;;346        
;;;347        /* Power enable */
;;;348        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000052  4819              LDR      r0,|L1.184|
000054  3024              ADDS     r0,r0,#0x24
000056  6802              LDR      r2,[r0,#0]
000058  f0425280          ORR      r2,r2,#0x10000000
00005c  6002              STR      r2,[r0,#0]
;;;349      
;;;350        /* Select the Voltage Range 1 (1.8 V) */
;;;351        PWR->CR = PWR_CR_VOS_0;
00005e  14c2              ASRS     r2,r0,#19
000060  4817              LDR      r0,|L1.192|
000062  6002              STR      r2,[r0,#0]
                  |L1.100|
;;;352      
;;;353        /* Wait Until the Voltage Regulator is ready */
;;;354        while((PWR->CSR & PWR_CSR_VOSF) != RESET)
000064  6842              LDR      r2,[r0,#4]
000066  06d2              LSLS     r2,r2,#27
000068  d4fc              BMI      |L1.100|
;;;355        {
;;;356        }
;;;357            
;;;358        /* HCLK = SYSCLK /1*/
;;;359        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00006a  4813              LDR      r0,|L1.184|
00006c  3008              ADDS     r0,r0,#8
00006e  6802              LDR      r2,[r0,#0]
000070  6002              STR      r2,[r0,#0]
;;;360      
;;;361        /* PCLK2 = HCLK /1*/
;;;362        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000072  6802              LDR      r2,[r0,#0]
000074  6002              STR      r2,[r0,#0]
;;;363        
;;;364        /* PCLK1 = HCLK /1*/
;;;365        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
000076  6802              LDR      r2,[r0,#0]
000078  6002              STR      r2,[r0,#0]
;;;366        
;;;367        /*  PLL configuration */
;;;368        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL |
00007a  6802              LDR      r2,[r0,#0]
00007c  f422027d          BIC      r2,r2,#0xfd0000
000080  6002              STR      r2,[r0,#0]
;;;369                                            RCC_CFGR_PLLDIV));
;;;370        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMUL12 | RCC_CFGR_PLLDIV3);
000082  6802              LDR      r2,[r0,#0]
000084  f4420211          ORR      r2,r2,#0x910000
000088  6002              STR      r2,[r0,#0]
;;;371    
;;;372        /* Enable PLL */
;;;373        RCC->CR |= RCC_CR_PLLON;
00008a  680a              LDR      r2,[r1,#0]
00008c  f0427280          ORR      r2,r2,#0x1000000
000090  600a              STR      r2,[r1,#0]
                  |L1.146|
;;;374    
;;;375        /* Wait till PLL is ready */
;;;376        while((RCC->CR & RCC_CR_PLLRDY) == 0)
000092  680a              LDR      r2,[r1,#0]
000094  0192              LSLS     r2,r2,#6
000096  d5fc              BPL      |L1.146|
;;;377        {
;;;378        }
;;;379            
;;;380        /* Select PLL as system clock source */
;;;381        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
000098  6801              LDR      r1,[r0,#0]
00009a  f0210103          BIC      r1,r1,#3
00009e  6001              STR      r1,[r0,#0]
;;;382        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
0000a0  6801              LDR      r1,[r0,#0]
0000a2  f0410103          ORR      r1,r1,#3
0000a6  6001              STR      r1,[r0,#0]
                  |L1.168|
;;;383    
;;;384        /* Wait till PLL is used as system clock source */
;;;385        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
0000a8  6801              LDR      r1,[r0,#0]
0000aa  f3c10181          UBFX     r1,r1,#2,#2
0000ae  2903              CMP      r1,#3
0000b0  d1fa              BNE      |L1.168|
;;;386        {
;;;387        }
;;;388      }
;;;389      else
;;;390      {
;;;391        /* If HSE fails to start-up, the application will have wrong clock
;;;392           configuration. User can add here some code to deal with this error */
;;;393      }
;;;394    }
0000b2  bd0c              POP      {r2,r3,pc}
                  |L1.180|
0000b4  9000              STR      r0,[sp,#0]            ;333
0000b6  bd0c              POP      {r2,r3,pc}
;;;395    
                          ENDP

                  |L1.184|
                          DCD      0x40023800
                  |L1.188|
                          DCD      0x40023c00
                  |L1.192|
                          DCD      0x40007000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;252      */
;;;253    void SystemCoreClockUpdate (void)
000000  491e              LDR      r1,|L2.124|
;;;254    {
000002  b510              PUSH     {r4,lr}
;;;255      uint32_t tmp = 0, pllmul = 0, plldiv = 0, pllsource = 0, msirange = 0;
;;;256    
;;;257      /* Get SYSCLK source -------------------------------------------------------*/
;;;258      tmp = RCC->CFGR & RCC_CFGR_SWS;
000004  6808              LDR      r0,[r1,#0]
;;;259      
;;;260      switch (tmp)
;;;261      {
;;;262        case 0x00:  /* MSI used as system clock */
;;;263          msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
000006  f1a10404          SUB      r4,r1,#4
00000a  f010030c          ANDS     r3,r0,#0xc            ;258
;;;264          SystemCoreClock = (32768 * (1 << (msirange + 1)));
00000e  481c              LDR      r0,|L2.128|
000010  f44f4200          MOV      r2,#0x8000
000014  d005              BEQ      |L2.34|
000016  2b04              CMP      r3,#4                 ;260
000018  d009              BEQ      |L2.46|
00001a  2b08              CMP      r3,#8                 ;260
00001c  d009              BEQ      |L2.50|
00001e  2b0c              CMP      r3,#0xc               ;260
000020  d009              BEQ      |L2.54|
                  |L2.34|
;;;265          break;
;;;266        case 0x04:  /* HSI used as system clock */
;;;267          SystemCoreClock = HSI_VALUE;
;;;268          break;
;;;269        case 0x08:  /* HSE used as system clock */
;;;270          SystemCoreClock = HSE_VALUE;
;;;271          break;
;;;272        case 0x0C:  /* PLL used as system clock */
;;;273          /* Get PLL clock source and multiplication factor ----------------------*/
;;;274          pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
;;;275          plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
;;;276          pllmul = PLLMulTable[(pllmul >> 18)];
;;;277          plldiv = (plldiv >> 22) + 1;
;;;278          
;;;279          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
;;;280    
;;;281          if (pllsource == 0x00)
;;;282          {
;;;283            /* HSI oscillator clock selected as PLL clock entry */
;;;284            SystemCoreClock = (((HSI_VALUE) * pllmul) / plldiv);
;;;285          }
;;;286          else
;;;287          {
;;;288            /* HSE selected as PLL clock entry */
;;;289            SystemCoreClock = (((HSE_VALUE) * pllmul) / plldiv);
;;;290          }
;;;291          break;
;;;292        default: /* MSI used as system clock */
;;;293          msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
000022  6823              LDR      r3,[r4,#0]
000024  f3c33342          UBFX     r3,r3,#13,#3
000028  1c5b              ADDS     r3,r3,#1
;;;294          SystemCoreClock = (32768 * (1 << (msirange + 1)));
00002a  409a              LSLS     r2,r2,r3
;;;295          break;
00002c  e019              B        |L2.98|
                  |L2.46|
00002e  4a15              LDR      r2,|L2.132|
000030  e017              B        |L2.98|
                  |L2.50|
000032  4a15              LDR      r2,|L2.136|
000034  e015              B        |L2.98|
                  |L2.54|
000036  680a              LDR      r2,[r1,#0]            ;274
000038  680b              LDR      r3,[r1,#0]            ;275
00003a  f4021270          AND      r2,r2,#0x3c0000       ;274
00003e  4c10              LDR      r4,|L2.128|
000040  f4030340          AND      r3,r3,#0xc00000       ;275
000044  1d24              ADDS     r4,r4,#4              ;276
000046  eb044292          ADD      r2,r4,r2,LSR #18      ;276
00004a  7812              LDRB     r2,[r2,#0]            ;276
00004c  2401              MOVS     r4,#1                 ;277
00004e  eb045393          ADD      r3,r4,r3,LSR #22      ;277
000052  680c              LDR      r4,[r1,#0]            ;279
000054  f4143f80          TST      r4,#0x10000           ;279
000058  d00e              BEQ      |L2.120|
00005a  4c0b              LDR      r4,|L2.136|
                  |L2.92|
00005c  4362              MULS     r2,r4,r2              ;284
00005e  fbb2f2f3          UDIV     r2,r2,r3              ;284
                  |L2.98|
;;;296      }
;;;297      /* Compute HCLK clock frequency --------------------------------------------*/
;;;298      /* Get HCLK prescaler */
;;;299      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000062  6002              STR      r2,[r0,#0]  ; SystemCoreClock
000064  6809              LDR      r1,[r1,#0]
000066  4a06              LDR      r2,|L2.128|
000068  f3c11103          UBFX     r1,r1,#4,#4
00006c  320d              ADDS     r2,r2,#0xd
00006e  5c51              LDRB     r1,[r2,r1]
;;;300      /* HCLK clock frequency */
;;;301      SystemCoreClock >>= tmp;
000070  6802              LDR      r2,[r0,#0]  ; SystemCoreClock
000072  40ca              LSRS     r2,r2,r1
000074  6002              STR      r2,[r0,#0]  ; SystemCoreClock
;;;302    }
000076  bd10              POP      {r4,pc}
                  |L2.120|
000078  4c02              LDR      r4,|L2.132|
00007a  e7ef              B        |L2.92|
;;;303    
                          ENDP

                  |L2.124|
                          DCD      0x40023808
                  |L2.128|
                          DCD      ||.data||
                  |L2.132|
                          DCD      0x00f42400
                  |L2.136|
                          DCD      0x007a1200

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;180      */
;;;181    void SystemInit (void)
000000  4810              LDR      r0,|L3.68|
;;;182    {
000002  b510              PUSH     {r4,lr}
;;;183      /*!< Set MSION bit */
;;;184      RCC->CR |= (uint32_t)0x00000100;
000004  6801              LDR      r1,[r0,#0]
000006  f4417180          ORR      r1,r1,#0x100
00000a  6001              STR      r1,[r0,#0]
;;;185    
;;;186      /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
;;;187      RCC->CFGR &= (uint32_t)0x88FFC00C;
00000c  490d              LDR      r1,|L3.68|
00000e  3108              ADDS     r1,r1,#8
000010  680a              LDR      r2,[r1,#0]
000012  4b0d              LDR      r3,|L3.72|
000014  401a              ANDS     r2,r2,r3
000016  600a              STR      r2,[r1,#0]
;;;188      
;;;189      /*!< Reset HSION, HSEON, CSSON and PLLON bits */
;;;190      RCC->CR &= (uint32_t)0xEEFEFFFE;
000018  6802              LDR      r2,[r0,#0]
00001a  4b0c              LDR      r3,|L3.76|
00001c  401a              ANDS     r2,r2,r3
00001e  6002              STR      r2,[r0,#0]
;;;191    
;;;192      /*!< Reset HSEBYP bit */
;;;193      RCC->CR &= (uint32_t)0xFFFBFFFF;
000020  6802              LDR      r2,[r0,#0]
000022  f4222280          BIC      r2,r2,#0x40000
000026  6002              STR      r2,[r0,#0]
;;;194    
;;;195      /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
;;;196      RCC->CFGR &= (uint32_t)0xFF02FFFF;
000028  6808              LDR      r0,[r1,#0]
00002a  f420007d          BIC      r0,r0,#0xfd0000
00002e  6008              STR      r0,[r1,#0]
;;;197    
;;;198      /*!< Disable all interrupts */
;;;199      RCC->CIR = 0x00000000;
000030  1d09              ADDS     r1,r1,#4
000032  2000              MOVS     r0,#0
000034  6008              STR      r0,[r1,#0]
;;;200    
;;;201    #ifdef DATA_IN_ExtSRAM
;;;202      SystemInit_ExtMemCtl(); 
;;;203    #endif /* DATA_IN_ExtSRAM */
;;;204        
;;;205      /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
;;;206      SetSysClock();
000036  f7fffffe          BL       SetSysClock
;;;207    
;;;208    #ifdef VECT_TAB_SRAM
;;;209      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;210    #else
;;;211      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
00003a  4905              LDR      r1,|L3.80|
00003c  f04f6000          MOV      r0,#0x8000000
000040  6008              STR      r0,[r1,#0]
;;;212    #endif
;;;213    }
000042  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  |L3.68|
                          DCD      0x40023800
                  |L3.72|
                          DCD      0x88ffc00c
                  |L3.76|
                          DCD      0xeefefffe
                  |L3.80|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x01e84800
                  PLLMulTable
000004  03040608          DCB      0x03,0x04,0x06,0x08
000008  0c101820          DCB      0x0c,0x10,0x18,0x20
00000c  30                DCB      0x30
                  AHBPrescTable
00000d  000000            DCB      0x00,0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00010203          DCB      0x00,0x01,0x02,0x03
000018  04060708          DCB      0x04,0x06,0x07,0x08
00001c  09                DCB      0x09

;*** Start embedded assembler ***

#line 1 "..\\src\\system_stm32l1xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32l1xx_c_5d646a67____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_system_stm32l1xx_c_5d646a67____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32l1xx_c_5d646a67____REVSH|
#line 144
|__asm___18_system_stm32l1xx_c_5d646a67____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
