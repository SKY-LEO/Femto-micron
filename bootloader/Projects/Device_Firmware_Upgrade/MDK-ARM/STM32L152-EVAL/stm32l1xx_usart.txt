; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_usart.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_usart.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_usart.crf ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;1314     */
;;;1315   void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  43c9              MVNS     r1,r1
;;;1316   {
;;;1317     /* Check the parameters */
;;;1318     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1319     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1320   
;;;1321     /* The CTS flag is not available for UART4 and UART5 */
;;;1322     if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
;;;1323     {
;;;1324       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1325     } 
;;;1326          
;;;1327     USARTx->SR = (uint16_t)~USART_FLAG;
000002  8001              STRH     r1,[r0,#0]
;;;1328   }
000004  4770              BX       lr
;;;1329   
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1424     */
;;;1425   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  0a0a              LSRS     r2,r1,#8
;;;1426   {
;;;1427     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1428     /* Check the parameters */
;;;1429     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1430     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1431   
;;;1432     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1433     if (USART_IT == USART_IT_CTS)
;;;1434     {
;;;1435       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1436     } 
;;;1437       
;;;1438     bitpos = USART_IT >> 0x08;
;;;1439     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000002  2101              MOVS     r1,#1
000004  4091              LSLS     r1,r1,r2
;;;1440     USARTx->SR = (uint16_t)~itmask;
000006  43c9              MVNS     r1,r1
000008  8001              STRH     r1,[r0,#0]
;;;1441   }
00000a  4770              BX       lr
;;;1442   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;347      */
;;;348    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;349    {
;;;350      uint32_t tmpreg = 0x00;
;;;351      /* Check the parameters */
;;;352      assert_param(IS_USART_123_PERIPH(USARTx));
;;;353      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;354      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;355      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;356      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;357      
;;;358    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;359      tmpreg = USARTx->CR2;
000002  8a02              LDRH     r2,[r0,#0x10]
;;;360      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;361      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
;;;362      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;363      /* Set CLKEN bit according to USART_Clock value */
;;;364      /* Set CPOL bit according to USART_CPOL value */
;;;365      /* Set CPHA bit according to USART_CPHA value */
;;;366      /* Set LBCL bit according to USART_LastBit value */
;;;367      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000004  884c              LDRH     r4,[r1,#2]
000006  f4226370          BIC      r3,r2,#0xf00          ;361
00000a  880a              LDRH     r2,[r1,#0]
00000c  4322              ORRS     r2,r2,r4
00000e  888c              LDRH     r4,[r1,#4]
000010  88c9              LDRH     r1,[r1,#6]
000012  430c              ORRS     r4,r4,r1
000014  4322              ORRS     r2,r2,r4
000016  431a              ORRS     r2,r2,r3
;;;368                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;369      /* Write to USART CR2 */
;;;370      USARTx->CR2 = (uint16_t)tmpreg;
000018  8202              STRH     r2,[r0,#0x10]
;;;371    }
00001a  bd10              POP      {r4,pc}
;;;372    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;378      */
;;;379    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;380    {
;;;381      /* USART_ClockInitStruct members default value */
;;;382      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;383      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;384      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;385      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;386    }
00000a  4770              BX       lr
;;;387    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;396      */
;;;397    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;398    {
;;;399      /* Check the parameters */
;;;400      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;401      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;402      
;;;403      if (NewState != DISABLE)
;;;404      {
;;;405        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;406        USARTx->CR1 |= USART_CR1_UE;
;;;407      }
;;;408      else
;;;409      {
;;;410        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;411        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L5.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;406
00000a  e001              B        |L5.16|
                  |L5.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L5.16|
000010  8181              STRH     r1,[r0,#0xc]          ;406
;;;412      }
;;;413    }
000012  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;1070     */
;;;1071   void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1072   {
;;;1073     /* Check the parameters */
;;;1074     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1075     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1076     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1077   
;;;1078     if (NewState != DISABLE)
;;;1079     {
;;;1080       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1081          DMAR bits in the USART CR3 register */
;;;1082       USARTx->CR3 |= USART_DMAReq;
;;;1083     }
;;;1084     else
;;;1085     {
;;;1086       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1087          DMAR bits in the USART CR3 register */
;;;1088       USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  d001              BEQ      |L6.10|
000006  430a              ORRS     r2,r2,r1              ;1082
000008  e000              B        |L6.12|
                  |L6.10|
00000a  438a              BICS     r2,r2,r1
                  |L6.12|
00000c  8282              STRH     r2,[r0,#0x14]         ;1082
;;;1089     }
;;;1090   }
00000e  4770              BX       lr
;;;1091   
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;172      */
;;;173    void USART_DeInit(USART_TypeDef* USARTx)
000000  4917              LDR      r1,|L7.96|
;;;174    {
000002  b510              PUSH     {r4,lr}
;;;175      /* Check the parameters */
;;;176      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;177    
;;;178      if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L7.30|
;;;179      {
;;;180        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  038c              LSLS     r4,r1,#14
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;181        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.30|
;;;182      }
;;;183      else if (USARTx == USART2)
00001e  4911              LDR      r1,|L7.100|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L7.42|
;;;184      {
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  044c              LSLS     r4,r1,#17
;;;186        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000028  e010              B        |L7.76|
                  |L7.42|
;;;187      }
;;;188      else if (USARTx == USART3)
00002a  490f              LDR      r1,|L7.104|
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L7.54|
;;;189      {
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000030  2101              MOVS     r1,#1
000032  048c              LSLS     r4,r1,#18
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000034  e00a              B        |L7.76|
                  |L7.54|
;;;192      }    
;;;193      else if (USARTx == UART4)
000036  490d              LDR      r1,|L7.108|
000038  4288              CMP      r0,r1
00003a  d102              BNE      |L7.66|
;;;194      {
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  04cc              LSLS     r4,r1,#19
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000040  e004              B        |L7.76|
                  |L7.66|
;;;197      }    
;;;198      else
;;;199      {
;;;200        if (USARTx == UART5)
000042  490b              LDR      r1,|L7.112|
000044  4288              CMP      r0,r1
000046  d10a              BNE      |L7.94|
;;;201        { 
;;;202          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000048  2101              MOVS     r1,#1
00004a  050c              LSLS     r4,r1,#20
                  |L7.76|
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;203          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000052  4620              MOV      r0,r4
000054  e8bd4010          POP      {r4,lr}
000058  2100              MOVS     r1,#0
00005a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.94|
;;;204        }
;;;205      }   
;;;206    }
00005e  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L7.96|
                          DCD      0x40013800
                  |L7.100|
                          DCD      0x40004400
                  |L7.104|
                          DCD      0x40004800
                  |L7.108|
                          DCD      0x40004c00
                  |L7.112|
                          DCD      0x40005000

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;1264     */
;;;1265   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;1266   {
;;;1267     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1268     /* Check the parameters */
;;;1269     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1270     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1271   
;;;1272     /* The CTS flag is not available for UART4 and UART5 */
;;;1273     if (USART_FLAG == USART_FLAG_CTS)
;;;1274     {
;;;1275       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1276     } 
;;;1277       
;;;1278     if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000004  8812              LDRH     r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;1279     {
;;;1280       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;1281     }
;;;1282     else
;;;1283     {
;;;1284       bitstatus = RESET;
;;;1285     }
;;;1286     return bitstatus;
;;;1287   }
00000c  4770              BX       lr
;;;1288   
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;1349     */
;;;1350   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1351   {
;;;1352     uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;1353     ITStatus bitstatus = RESET;
;;;1354     /* Check the parameters */
;;;1355     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1356     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1357   
;;;1358     /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;1359     if (USART_IT == USART_IT_CTS)
;;;1360     {
;;;1361       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1362     } 
;;;1363       
;;;1364     /* Get the USART register index */
;;;1365     usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;1366     /* Get the interrupt position */
;;;1367     itmask = USART_IT & IT_MASK;
000002  f001021f          AND      r2,r1,#0x1f
;;;1368     itmask = (uint32_t)0x01 << itmask;
000006  2401              MOVS     r4,#1
000008  2500              MOVS     r5,#0                 ;1353
00000a  f3c11342          UBFX     r3,r1,#5,#3           ;1365
00000e  fa04f202          LSL      r2,r4,r2
;;;1369     
;;;1370     if (usartreg == 0x01) /* The IT  is in CR1 register */
000012  2b01              CMP      r3,#1
000014  d00f              BEQ      |L9.54|
;;;1371     {
;;;1372       itmask &= USARTx->CR1;
;;;1373     }
;;;1374     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000016  2b02              CMP      r3,#2
000018  d00f              BEQ      |L9.58|
;;;1375     {
;;;1376       itmask &= USARTx->CR2;
;;;1377     }
;;;1378     else /* The IT  is in CR3 register */
;;;1379     {
;;;1380       itmask &= USARTx->CR3;
00001a  8a83              LDRH     r3,[r0,#0x14]
                  |L9.28|
;;;1381     }
;;;1382     
;;;1383     bitpos = USART_IT >> 0x08;
00001c  ea4f2111          LSR      r1,r1,#8
;;;1384     bitpos = (uint32_t)0x01 << bitpos;
;;;1385     bitpos &= USARTx->SR;
000020  8800              LDRH     r0,[r0,#0]
000022  4213              TST      r3,r2                 ;1376
000024  fa04f401          LSL      r4,r4,r1              ;1384
000028  ea000004          AND      r0,r0,r4
00002c  d001              BEQ      |L9.50|
;;;1386     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00002e  b100              CBZ      r0,|L9.50|
;;;1387     {
;;;1388       bitstatus = SET;
000030  2501              MOVS     r5,#1
                  |L9.50|
;;;1389     }
;;;1390     else
;;;1391     {
;;;1392       bitstatus = RESET;
;;;1393     }
;;;1394     
;;;1395     return bitstatus;  
000032  4628              MOV      r0,r5
;;;1396   }
000034  bd30              POP      {r4,r5,pc}
                  |L9.54|
000036  8983              LDRH     r3,[r0,#0xc]          ;1372
000038  e7f0              B        |L9.28|
                  |L9.58|
00003a  8a03              LDRH     r3,[r0,#0x10]         ;1376
00003c  e7ee              B        |L9.28|
;;;1397   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;804      */
;;;805    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;806    {
;;;807      /* Check the parameters */
;;;808      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;809      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;810      
;;;811      if (NewState != DISABLE)
;;;812      {
;;;813        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;814        USARTx->CR3 |= USART_CR3_HDSEL;
;;;815      }
;;;816      else
;;;817      {
;;;818        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;819        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L10.12|
000006  f0410108          ORR      r1,r1,#8              ;814
00000a  e001              B        |L10.16|
                  |L10.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L10.16|
000010  8281              STRH     r1,[r0,#0x14]         ;814
;;;820      }
;;;821    }
000012  4770              BX       lr
;;;822    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;1199     */
;;;1200   void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1201   {
;;;1202     uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;1203     uint32_t usartxbase = 0x00;
;;;1204     /* Check the parameters */
;;;1205     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1206     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1207     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1208   
;;;1209     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1210     if (USART_IT == USART_IT_CTS)
;;;1211     {
;;;1212       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1213     } 
;;;1214       
;;;1215     usartxbase = (uint32_t)USARTx;
;;;1216   
;;;1217     /* Get the USART register index */
;;;1218     usartreg = (((uint8_t)USART_IT) >> 0x05);
000002  f3c11342          UBFX     r3,r1,#5,#3
;;;1219   
;;;1220     /* Get the interrupt position */
;;;1221     itpos = USART_IT & IT_MASK;
000006  f001041f          AND      r4,r1,#0x1f
;;;1222     itmask = (((uint32_t)0x01) << itpos);
00000a  2101              MOVS     r1,#1
00000c  40a1              LSLS     r1,r1,r4
;;;1223       
;;;1224     if (usartreg == 0x01) /* The IT is in CR1 register */
00000e  2b01              CMP      r3,#1
000010  d007              BEQ      |L11.34|
;;;1225     {
;;;1226       usartxbase += 0x0C;
;;;1227     }
;;;1228     else if (usartreg == 0x02) /* The IT is in CR2 register */
000012  2b02              CMP      r3,#2
000014  d007              BEQ      |L11.38|
000016  3014              ADDS     r0,r0,#0x14
                  |L11.24|
;;;1229     {
;;;1230       usartxbase += 0x10;
;;;1231     }
;;;1232     else /* The IT is in CR3 register */
;;;1233     {
;;;1234       usartxbase += 0x14; 
;;;1235     }
;;;1236     if (NewState != DISABLE)
000018  2a00              CMP      r2,#0
;;;1237     {
;;;1238       *(__IO uint32_t*)usartxbase  |= itmask;
;;;1239     }
;;;1240     else
;;;1241     {
;;;1242       *(__IO uint32_t*)usartxbase &= ~itmask;
00001a  6802              LDR      r2,[r0,#0]
00001c  d005              BEQ      |L11.42|
00001e  430a              ORRS     r2,r2,r1              ;1238
000020  e004              B        |L11.44|
                  |L11.34|
000022  300c              ADDS     r0,r0,#0xc            ;1238
000024  e7f8              B        |L11.24|
                  |L11.38|
000026  3010              ADDS     r0,r0,#0x10           ;1226
000028  e7f6              B        |L11.24|
                  |L11.42|
00002a  438a              BICS     r2,r2,r1
                  |L11.44|
00002c  6002              STR      r2,[r0,#0]            ;1238
;;;1243     }
;;;1244   }
00002e  bd10              POP      {r4,pc}
;;;1245   
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;217      */
;;;218    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;219    {
000002  4604              MOV      r4,r0
;;;220      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;221      uint32_t integerdivider = 0x00;
;;;222      uint32_t fractionaldivider = 0x00;
;;;223      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;224    
;;;225      /* Check the parameters */
;;;226      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;227      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;228      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;229      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;230      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;231      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;232      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;233    
;;;234      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;235      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
;;;236      {
;;;237        assert_param(IS_USART_123_PERIPH(USARTx));
;;;238      }
;;;239       
;;;240    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;241      tmpreg = USARTx->CR2;
000004  8a00              LDRH     r0,[r0,#0x10]
000006  460d              MOV      r5,r1                 ;219
;;;242      /* Clear STOP[13:12] bits */
;;;243      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
000008  f4205140          BIC      r1,r0,#0x3000
;;;244    
;;;245      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;246      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;247      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00000c  88e8              LDRH     r0,[r5,#6]
00000e  4308              ORRS     r0,r0,r1
;;;248      
;;;249      /* Write to USART CR2 */
;;;250      USARTx->CR2 = (uint16_t)tmpreg;
000010  8220              STRH     r0,[r4,#0x10]
;;;251    
;;;252    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;253      tmpreg = USARTx->CR1;
000012  89a0              LDRH     r0,[r4,#0xc]
;;;254      /* Clear M, PCE, PS, TE and RE bits */
;;;255      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
000014  f241610c          MOV      r1,#0x160c
000018  4388              BICS     r0,r0,r1
;;;256    
;;;257      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;258      /* Set the M bits according to USART_WordLength value */
;;;259      /* Set PCE and PS bits according to USART_Parity value */
;;;260      /* Set TE and RE bits according to USART_Mode value */
;;;261      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00001a  88a9              LDRH     r1,[r5,#4]
00001c  892a              LDRH     r2,[r5,#8]
00001e  4311              ORRS     r1,r1,r2
000020  896a              LDRH     r2,[r5,#0xa]
000022  4302              ORRS     r2,r2,r0
000024  4311              ORRS     r1,r1,r2
;;;262                USART_InitStruct->USART_Mode;
;;;263    
;;;264      /* Write to USART CR1 */
;;;265      USARTx->CR1 = (uint16_t)tmpreg;
000026  81a1              STRH     r1,[r4,#0xc]
;;;266    
;;;267    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;268      tmpreg = USARTx->CR3;
000028  8aa0              LDRH     r0,[r4,#0x14]
;;;269      /* Clear CTSE and RTSE bits */
;;;270      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
00002a  f4207140          BIC      r1,r0,#0x300
;;;271    
;;;272      /* Configure the USART HFC -------------------------------------------------*/
;;;273      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;274      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
00002e  89a8              LDRH     r0,[r5,#0xc]
000030  4308              ORRS     r0,r0,r1
;;;275    
;;;276      /* Write to USART CR3 */
;;;277      USARTx->CR3 = (uint16_t)tmpreg;
000032  82a0              STRH     r0,[r4,#0x14]
;;;278    
;;;279    /*---------------------------- USART BRR Configuration -----------------------*/
;;;280      /* Configure the USART Baud Rate -------------------------------------------*/
;;;281      RCC_GetClocksFreq(&RCC_ClocksStatus);
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       RCC_GetClocksFreq
;;;282      if (USARTx == USART1) 
00003a  4819              LDR      r0,|L12.160|
00003c  4284              CMP      r4,r0
00003e  d101              BNE      |L12.68|
;;;283      {
;;;284        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000040  9803              LDR      r0,[sp,#0xc]
000042  e000              B        |L12.70|
                  |L12.68|
;;;285      }
;;;286      else
;;;287      {
;;;288        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000044  9802              LDR      r0,[sp,#8]
                  |L12.70|
;;;289      }
;;;290    
;;;291      /* Determine the integer part */
;;;292      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000046  89a1              LDRH     r1,[r4,#0xc]
000048  0409              LSLS     r1,r1,#16
;;;293      {
;;;294        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;295        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;296      }
;;;297      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;298      {
;;;299        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;300        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6829              LDR      r1,[r5,#0]            ;292
000054  d501              BPL      |L12.90|
000056  0049              LSLS     r1,r1,#1              ;295
000058  e000              B        |L12.92|
                  |L12.90|
00005a  0089              LSLS     r1,r1,#2
                  |L12.92|
00005c  fbb0f0f1          UDIV     r0,r0,r1
;;;301      }
;;;302      tmpreg = (integerdivider / 100) << 4;
000060  2264              MOVS     r2,#0x64
000062  fbb0f1f2          UDIV     r1,r0,r2
000066  0109              LSLS     r1,r1,#4
;;;303    
;;;304      /* Determine the fractional part */
;;;305      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000068  090b              LSRS     r3,r1,#4
00006a  f06f0518          MVN      r5,#0x18
00006e  436b              MULS     r3,r5,r3
000070  eb000083          ADD      r0,r0,r3,LSL #2
;;;306    
;;;307      /* Implement the fractional part in the register */
;;;308      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000074  89a3              LDRH     r3,[r4,#0xc]
000076  041d              LSLS     r5,r3,#16
;;;309      {
;;;310        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000078  f04f0332          MOV      r3,#0x32
00007c  d506              BPL      |L12.140|
00007e  eb0300c0          ADD      r0,r3,r0,LSL #3
000082  fbb0f0f2          UDIV     r0,r0,r2
000086  f0000007          AND      r0,r0,#7
00008a  e005              B        |L12.152|
                  |L12.140|
;;;311      }
;;;312      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;313      {
;;;314        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
00008c  eb031000          ADD      r0,r3,r0,LSL #4
000090  fbb0f0f2          UDIV     r0,r0,r2
000094  f000000f          AND      r0,r0,#0xf
                  |L12.152|
000098  4308              ORRS     r0,r0,r1
;;;315      }
;;;316     
;;;317      /* Write to USART BRR */
;;;318      USARTx->BRR = (uint16_t)tmpreg;
00009a  8120              STRH     r0,[r4,#8]
;;;319    }
00009c  bd7f              POP      {r0-r6,pc}
;;;320    
                          ENDP

00009e  0000              DCW      0x0000
                  |L12.160|
                          DCD      0x40013800

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;1023     */
;;;1024   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1025   {
;;;1026     /* Check the parameters */
;;;1027     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1028     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1029       
;;;1030     if (NewState != DISABLE)
;;;1031     {
;;;1032       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1033       USARTx->CR3 |= USART_CR3_IREN;
;;;1034     }
;;;1035     else
;;;1036     {
;;;1037       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1038       USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L13.12|
000006  f0410102          ORR      r1,r1,#2              ;1033
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L13.16|
000010  8281              STRH     r1,[r0,#0x14]         ;1033
;;;1039     }
;;;1040   }
000012  4770              BX       lr
;;;1041   
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;1004     */
;;;1005   void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;1006   {
;;;1007     /* Check the parameters */
;;;1008     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1009     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1010       
;;;1011     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
000002  f0220204          BIC      r2,r2,#4
000006  8282              STRH     r2,[r0,#0x14]
;;;1012     USARTx->CR3 |= USART_IrDAMode;
000008  8a82              LDRH     r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  8282              STRH     r2,[r0,#0x14]
;;;1013   }
00000e  4770              BX       lr
;;;1014   
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;711      */
;;;712    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;713    {
;;;714      /* Check the parameters */
;;;715      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;716      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;717      
;;;718      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
000002  f0220220          BIC      r2,r2,#0x20
000006  8202              STRH     r2,[r0,#0x10]
;;;719      USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;720    }
00000e  4770              BX       lr
;;;721    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;730      */
;;;731    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;732    {
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;736      
;;;737      if (NewState != DISABLE)
;;;738      {
;;;739        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;740        USARTx->CR2 |= USART_CR2_LINEN;
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;745        USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
000002  8a01              LDRH     r1,[r0,#0x10]
000004  d002              BEQ      |L16.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;740
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L16.16|
000010  8201              STRH     r1,[r0,#0x10]         ;740
;;;746      }
;;;747    }
000012  4770              BX       lr
;;;748    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;474      */
;;;475    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;476    {
;;;477      /* Check the parameters */
;;;478      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;479      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;480      
;;;481      if (NewState != DISABLE)
;;;482      {
;;;483        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;484        USARTx->CR3 |= USART_CR3_ONEBIT;
;;;485      }
;;;486      else
;;;487      {
;;;488        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;489        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L17.12|
000006  f4416100          ORR      r1,r1,#0x800          ;484
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L17.16|
000010  8281              STRH     r1,[r0,#0x14]         ;484
;;;490      }
;;;491    }
000012  4770              BX       lr
;;;492    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;447      */
;;;448    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;452      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;453      
;;;454      if (NewState != DISABLE)
;;;455      {
;;;456        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;457        USARTx->CR1 |= USART_CR1_OVER8;
;;;458      }
;;;459      else
;;;460      {
;;;461        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;462        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L18.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;457
00000a  e001              B        |L18.16|
                  |L18.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L18.16|
000010  8181              STRH     r1,[r0,#0xc]          ;457
;;;463      }
;;;464    }  
000012  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;545      */
;;;546    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  8880              LDRH     r0,[r0,#4]
;;;547    {
;;;548      /* Check the parameters */
;;;549      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;550      
;;;551      /* Receive Data */
;;;552      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;553    }
000006  4770              BX       lr
;;;554    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;618      */
;;;619    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;620    {
;;;621      /* Check the parameters */
;;;622      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;623      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;624      
;;;625      if (NewState != DISABLE)
;;;626      {
;;;627        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;628        USARTx->CR1 |= USART_CR1_RWU;
;;;629      }
;;;630      else
;;;631      {
;;;632        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;633        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L20.12|
000006  f0410102          ORR      r1,r1,#2              ;628
00000a  e001              B        |L20.16|
                  |L20.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L20.16|
000010  8181              STRH     r1,[r0,#0xc]          ;628
;;;634      }
;;;635    }
000012  4770              BX       lr
;;;636    /**
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;755      */
;;;756    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;757    {
;;;758      /* Check the parameters */
;;;759      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;760      
;;;761      /* Send break characters */
;;;762      USARTx->CR1 |= USART_CR1_SBK;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;763    }
000008  4770              BX       lr
;;;764    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;528      */
;;;529    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;530    {
;;;531      /* Check the parameters */
;;;532      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;533      assert_param(IS_USART_DATA(Data)); 
;;;534        
;;;535      /* Transmit Data */
;;;536      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8081              STRH     r1,[r0,#4]
;;;537    }
000006  4770              BX       lr
;;;538    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;597      */
;;;598    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;599    {
;;;600      /* Check the parameters */
;;;601      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;602      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;603        
;;;604      /* Clear the USART address */
;;;605      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
000002  f022020f          BIC      r2,r2,#0xf
000006  8202              STRH     r2,[r0,#0x10]
;;;606      /* Set the USART address node */
;;;607      USARTx->CR2 |= USART_Address;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;608    }
00000e  4770              BX       lr
;;;609    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;886      */
;;;887    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;888    {    
;;;889      /* Check the parameters */
;;;890      assert_param(IS_USART_123_PERIPH(USARTx));
;;;891      
;;;892      /* Clear the USART Guard time */
;;;893      USARTx->GTPR &= USART_GTPR_PSC;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;894      /* Set the USART guard time */
;;;895      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8301              STRH     r1,[r0,#0x18]
;;;896    }
00000e  4770              BX       lr
;;;897    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;423      */
;;;424    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;425    { 
;;;426      /* Check the parameters */
;;;427      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;428      
;;;429      /* Clear the USART prescaler */
;;;430      USARTx->GTPR &= USART_GTPR_GT;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;431      /* Set the USART prescaler */
;;;432      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;433    }
00000e  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;906      */
;;;907    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;908    {
;;;909      /* Check the parameters */
;;;910      assert_param(IS_USART_123_PERIPH(USARTx));
;;;911      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;912      if (NewState != DISABLE)
;;;913      {
;;;914        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;915        USARTx->CR3 |= USART_CR3_SCEN;
;;;916      }
;;;917      else
;;;918      {
;;;919        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;920        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L26.12|
000006  f0410120          ORR      r1,r1,#0x20           ;915
00000a  e001              B        |L26.16|
                  |L26.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L26.16|
000010  8281              STRH     r1,[r0,#0x14]         ;915
;;;921      }
;;;922    }
000012  4770              BX       lr
;;;923    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;932      */
;;;933    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;934    {
;;;935      /* Check the parameters */
;;;936      assert_param(IS_USART_123_PERIPH(USARTx)); 
;;;937      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;938      if (NewState != DISABLE)
;;;939      {
;;;940        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;941        USARTx->CR3 |= USART_CR3_NACK;
;;;942      }
;;;943      else
;;;944      {
;;;945        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;946        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L27.12|
000006  f0410110          ORR      r1,r1,#0x10           ;941
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L27.16|
000010  8281              STRH     r1,[r0,#0x14]         ;941
;;;947      }
;;;948    }
000012  4770              BX       lr
;;;949    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;326      */
;;;327    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;328    {
;;;329      /* USART_InitStruct members default value */
;;;330      USART_InitStruct->USART_BaudRate = 9600;
;;;331      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;332      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;333      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;334      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;335      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;336    }
000014  4770              BX       lr
;;;337    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;646      */
;;;647    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;648    {
;;;649      /* Check the parameters */
;;;650      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;651      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;652      
;;;653      USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
000002  f4226200          BIC      r2,r2,#0x800
000006  8182              STRH     r2,[r0,#0xc]
;;;654      USARTx->CR1 |= USART_WakeUp;
000008  8982              LDRH     r2,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  8182              STRH     r2,[r0,#0xc]
;;;655    }
00000e  4770              BX       lr
;;;656    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32l1xx_usart_c_9565154b____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32l1xx_usart_c_9565154b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32l1xx_usart_c_9565154b____REVSH|
#line 144
|__asm___17_stm32l1xx_usart_c_9565154b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
