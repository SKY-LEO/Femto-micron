; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_rcc.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_rcc.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_rcc.crf ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1104     */
;;;1105   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L1.20|
;;;1106   {
;;;1107     /* Check the parameters */
;;;1108     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1109     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1110     
;;;1111     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1112     {
;;;1113       RCC->AHBENR |= RCC_AHBPeriph;
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;1113
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;1113
;;;1118     }
;;;1119   }
000010  4770              BX       lr
;;;1120   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x4002381c

                          AREA ||i.RCC_AHBPeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockLPModeCmd PROC
;;;1343     */
;;;1344   void RCC_AHBPeriphClockLPModeCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1345   {
;;;1346     /* Check the parameters */
;;;1347     assert_param(IS_RCC_AHB_LPMODE_PERIPH(RCC_AHBPeriph));
;;;1348     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1349     
;;;1350     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1351     {
;;;1352       RCC->AHBLPENR |= RCC_AHBPeriph;
;;;1353     }
;;;1354     else
;;;1355     {
;;;1356       RCC->AHBLPENR &= ~RCC_AHBPeriph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1352
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6011              STR      r1,[r2,#0]            ;1352
;;;1357     }
;;;1358   }
000010  4770              BX       lr
;;;1359   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40023828

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;1224     */
;;;1225   void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1226   {
;;;1227     /* Check the parameters */
;;;1228     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1229     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1230   
;;;1231     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1232     {
;;;1233       RCC->AHBRSTR |= RCC_AHBPeriph;
;;;1234     }
;;;1235     else
;;;1236     {
;;;1237       RCC->AHBRSTR &= ~RCC_AHBPeriph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1233
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6011              STR      r1,[r2,#0]            ;1233
;;;1238     }
;;;1239   }
000010  4770              BX       lr
;;;1240   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40023810

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1186     */
;;;1187   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1188   {
;;;1189     /* Check the parameters */
;;;1190     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1191     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1192   
;;;1193     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1194     {
;;;1195       RCC->APB1ENR |= RCC_APB1Periph;
;;;1196     }
;;;1197     else
;;;1198     {
;;;1199       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1195
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6011              STR      r1,[r2,#0]            ;1195
;;;1200     }
;;;1201   }
000010  4770              BX       lr
;;;1202   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40023824

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1428     */
;;;1429   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1430   {
;;;1431     /* Check the parameters */
;;;1432     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1433     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1434     
;;;1435     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1436     {
;;;1437       RCC->APB1LPENR |= RCC_APB1Periph;
;;;1438     }
;;;1439     else
;;;1440     {
;;;1441       RCC->APB1LPENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1437
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;1437
;;;1442     }
;;;1443   }
000010  4770              BX       lr
;;;1444   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40023830

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1300     */
;;;1301   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1302   {
;;;1303     /* Check the parameters */
;;;1304     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1305     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1306   
;;;1307     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1308     {
;;;1309       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1310     }
;;;1311     else
;;;1312     {
;;;1313       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1309
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6011              STR      r1,[r2,#0]            ;1309
;;;1314     }
;;;1315   }
000010  4770              BX       lr
;;;1316   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40023818

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1139     */
;;;1140   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1141   {
;;;1142     /* Check the parameters */
;;;1143     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1144     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1145   
;;;1146     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1147     {
;;;1148       RCC->APB2ENR |= RCC_APB2Periph;
;;;1149     }
;;;1150     else
;;;1151     {
;;;1152       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;1148
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  6011              STR      r1,[r2,#0]            ;1148
;;;1153     }
;;;1154   }
000010  4770              BX       lr
;;;1155   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1379     */
;;;1380   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;1381   {
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1384     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1385     
;;;1386     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1387     {
;;;1388       RCC->APB2LPENR |= RCC_APB2Periph;
;;;1389     }
;;;1390     else
;;;1391     {
;;;1392       RCC->APB2LPENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;1388
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6011              STR      r1,[r2,#0]            ;1388
;;;1393     }
;;;1394   }
000010  4770              BX       lr
;;;1395   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x4002382c

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1256     */
;;;1257   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;1258   {
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1261     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1262   
;;;1263     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1264     {
;;;1265       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;1265
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;1265
;;;1270     }
;;;1271   }
000010  4770              BX       lr
;;;1272   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40023814

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;385      */
;;;386    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L10.16|
;;;387    {
;;;388      uint32_t tmpreg = 0;
;;;389      
;;;390      /* Check the parameters */
;;;391      assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
;;;392      
;;;393      tmpreg = RCC->ICSCR;
000002  680a              LDR      r2,[r1,#0]
;;;394      
;;;395      /* Clear HSITRIM[4:0] bits */
;;;396      tmpreg &= ~RCC_ICSCR_HSITRIM;
000004  f42252f8          BIC      r2,r2,#0x1f00
;;;397      
;;;398      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;399      tmpreg |= (uint32_t)HSICalibrationValue << 8;
000008  ea422000          ORR      r0,r2,r0,LSL #8
;;;400    
;;;401      /* Store the new value */
;;;402      RCC->ICSCR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;403    }
00000e  4770              BX       lr
;;;404    
                          ENDP

                  |L10.16|
                          DCD      0x40023804

                          AREA ||i.RCC_AdjustMSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustMSICalibrationValue PROC
;;;302      */
;;;303    void RCC_AdjustMSICalibrationValue(uint8_t MSICalibrationValue)
000000  4901              LDR      r1,|L11.8|
;;;304    {
;;;305      
;;;306      /* Check the parameters */
;;;307      assert_param(IS_RCC_MSI_CALIBRATION_VALUE(MSICalibrationValue));
;;;308    
;;;309      *(__IO uint8_t *) ICSCR_BYTE4_ADDRESS = MSICalibrationValue;  
000002  7008              STRB     r0,[r1,#0]
;;;310    }
000004  4770              BX       lr
;;;311    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40023807

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1562     */
;;;1563   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L12.12|
;;;1564   {
;;;1565     /* Set RMVF bit to clear the reset flags */
;;;1566     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;1567   }
00000a  4770              BX       lr
;;;1568   
                          ENDP

                  |L12.12|
                          DCD      0x40023834

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1615     */
;;;1616   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L13.8|
;;;1617   {
;;;1618     /* Check the parameters */
;;;1619     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1620     
;;;1621     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1622        pending bits */
;;;1623     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;1624   }
000004  4770              BX       lr
;;;1625   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;555      */
;;;556    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L14.8|
;;;557    {
;;;558      /* Check the parameters */
;;;559      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;560      
;;;561      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  6708              STR      r0,[r1,#0x70]
;;;562    }
000004  4770              BX       lr
;;;563    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;201      */
;;;202    void RCC_DeInit(void)
000000  480d              LDR      r0,|L15.56|
;;;203    {
;;;204      
;;;205      /* Set MSION bit */
;;;206      RCC->CR |= (uint32_t)0x00000100;
000002  6801              LDR      r1,[r0,#0]
000004  f4417180          ORR      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;207    
;;;208      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
;;;209      RCC->CFGR &= (uint32_t)0x88FFC00C;
00000a  490b              LDR      r1,|L15.56|
00000c  3108              ADDS     r1,r1,#8
00000e  680a              LDR      r2,[r1,#0]
000010  4b0a              LDR      r3,|L15.60|
000012  401a              ANDS     r2,r2,r3
000014  600a              STR      r2,[r1,#0]
;;;210      
;;;211      /* Reset HSION, HSEON, CSSON and PLLON bits */
;;;212      RCC->CR &= (uint32_t)0xEEFEFFFE;
000016  6802              LDR      r2,[r0,#0]
000018  4b09              LDR      r3,|L15.64|
00001a  401a              ANDS     r2,r2,r3
00001c  6002              STR      r2,[r0,#0]
;;;213    
;;;214      /* Reset HSEBYP bit */
;;;215      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001e  6802              LDR      r2,[r0,#0]
000020  f4222280          BIC      r2,r2,#0x40000
000024  6002              STR      r2,[r0,#0]
;;;216    
;;;217      /* Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
;;;218      RCC->CFGR &= (uint32_t)0xFF02FFFF;
000026  6808              LDR      r0,[r1,#0]
000028  f420007d          BIC      r0,r0,#0xfd0000
00002c  6008              STR      r0,[r1,#0]
;;;219    
;;;220      /* Disable all interrupts */
;;;221      RCC->CIR = 0x00000000;
00002e  2000              MOVS     r0,#0
000030  1d09              ADDS     r1,r1,#4
000032  6008              STR      r0,[r1,#0]
;;;222    }
000034  4770              BX       lr
;;;223    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x40023800
                  |L15.60|
                          DCD      0x88ffc00c
                  |L15.64|
                          DCD      0xeefefffe

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;890      */
;;;891    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;892    {
;;;893      uint32_t tmp = 0, pllmul = 0, plldiv = 0, pllsource = 0, presc = 0, msirange = 0;
;;;894    
;;;895      /* Get SYSCLK source -------------------------------------------------------*/
;;;896      tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4a25              LDR      r2,|L16.152|
000004  6811              LDR      r1,[r2,#0]
;;;897      
;;;898      switch (tmp)
;;;899      {
;;;900        case 0x00:  /* MSI used as system clock */
;;;901          msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> 13;
000006  f1a20404          SUB      r4,r2,#4
00000a  f011030c          ANDS     r3,r1,#0xc            ;896
;;;902          RCC_Clocks->SYSCLK_Frequency = (32768 * (1 << (msirange + 1)));
00000e  f44f4100          MOV      r1,#0x8000
000012  d005              BEQ      |L16.32|
000014  2b04              CMP      r3,#4                 ;898
000016  d009              BEQ      |L16.44|
000018  2b08              CMP      r3,#8                 ;898
00001a  d009              BEQ      |L16.48|
00001c  2b0c              CMP      r3,#0xc               ;898
00001e  d009              BEQ      |L16.52|
                  |L16.32|
;;;903          break;
;;;904        case 0x04:  /* HSI used as system clock */
;;;905          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;906          break;
;;;907        case 0x08:  /* HSE used as system clock */
;;;908          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
;;;909          break;
;;;910        case 0x0C:  /* PLL used as system clock */
;;;911          /* Get PLL clock source and multiplication factor ----------------------*/
;;;912          pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
;;;913          plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
;;;914          pllmul = PLLMulTable[(pllmul >> 18)];
;;;915          plldiv = (plldiv >> 22) + 1;
;;;916          
;;;917          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
;;;918    
;;;919          if (pllsource == 0x00)
;;;920          {
;;;921            /* HSI oscillator clock selected as PLL clock source */
;;;922            RCC_Clocks->SYSCLK_Frequency = (((HSI_VALUE) * pllmul) / plldiv);
;;;923          }
;;;924          else
;;;925          {
;;;926            /* HSE selected as PLL clock source */
;;;927            RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE) * pllmul) / plldiv);
;;;928          }
;;;929          break;
;;;930        default: /* MSI used as system clock */
;;;931          msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> 13;
000020  6823              LDR      r3,[r4,#0]
000022  f3c33342          UBFX     r3,r3,#13,#3
000026  1c5b              ADDS     r3,r3,#1
;;;932          RCC_Clocks->SYSCLK_Frequency = (32768 * (1 << (msirange + 1)));
000028  4099              LSLS     r1,r1,r3
;;;933          break;
00002a  e018              B        |L16.94|
                  |L16.44|
00002c  491b              LDR      r1,|L16.156|
00002e  e016              B        |L16.94|
                  |L16.48|
000030  491b              LDR      r1,|L16.160|
000032  e014              B        |L16.94|
                  |L16.52|
000034  6811              LDR      r1,[r2,#0]            ;912
000036  6813              LDR      r3,[r2,#0]            ;913
000038  f4011170          AND      r1,r1,#0x3c0000       ;912
00003c  4c19              LDR      r4,|L16.164|
00003e  f4030340          AND      r3,r3,#0xc00000       ;913
000042  eb044191          ADD      r1,r4,r1,LSR #18      ;914
000046  7809              LDRB     r1,[r1,#0]            ;914
000048  2401              MOVS     r4,#1                 ;915
00004a  eb045393          ADD      r3,r4,r3,LSR #22      ;915
00004e  6814              LDR      r4,[r2,#0]            ;917
000050  f4143f80          TST      r4,#0x10000           ;917
000054  d01d              BEQ      |L16.146|
000056  4c12              LDR      r4,|L16.160|
                  |L16.88|
000058  4361              MULS     r1,r4,r1              ;922
00005a  fbb1f1f3          UDIV     r1,r1,r3              ;922
                  |L16.94|
;;;934      }
;;;935      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;936      /* Get HCLK prescaler */
;;;937      tmp = RCC->CFGR & RCC_CFGR_HPRE;
00005e  6001              STR      r1,[r0,#0]
000060  6811              LDR      r1,[r2,#0]
;;;938      tmp = tmp >> 4;
;;;939      presc = APBAHBPrescTable[tmp]; 
;;;940      /* HCLK clock frequency */
;;;941      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;942    
;;;943      /* Get PCLK1 prescaler */
;;;944      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;945      tmp = tmp >> 8;
;;;946      presc = APBAHBPrescTable[tmp];
;;;947      /* PCLK1 clock frequency */
;;;948      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;949    
;;;950      /* Get PCLK2 prescaler */
;;;951      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;952      tmp = tmp >> 11;
;;;953      presc = APBAHBPrescTable[tmp];
;;;954      /* PCLK2 clock frequency */
;;;955      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;956    }
000062  230f              MOVS     r3,#0xf
000064  ea031111          AND      r1,r3,r1,LSR #4
000068  4b0e              LDR      r3,|L16.164|
00006a  3309              ADDS     r3,r3,#9              ;939
00006c  5c5c              LDRB     r4,[r3,r1]            ;939
00006e  6801              LDR      r1,[r0,#0]            ;941
000070  40e1              LSRS     r1,r1,r4              ;941
000072  6041              STR      r1,[r0,#4]            ;944
000074  6814              LDR      r4,[r2,#0]            ;944
000076  2507              MOVS     r5,#7
000078  ea052414          AND      r4,r5,r4,LSR #8
00007c  5d1c              LDRB     r4,[r3,r4]            ;946
00007e  fa21f404          LSR      r4,r1,r4              ;948
000082  6084              STR      r4,[r0,#8]            ;951
000084  6812              LDR      r2,[r2,#0]            ;951
000086  ea0522d2          AND      r2,r5,r2,LSR #11
00008a  5c9a              LDRB     r2,[r3,r2]            ;953
00008c  40d1              LSRS     r1,r1,r2              ;955
00008e  60c1              STR      r1,[r0,#0xc]          ;955
000090  bd30              POP      {r4,r5,pc}
                  |L16.146|
000092  4c02              LDR      r4,|L16.156|
000094  e7e0              B        |L16.88|
;;;957    
                          ENDP

000096  0000              DCW      0x0000
                  |L16.152|
                          DCD      0x40023808
                  |L16.156|
                          DCD      0x00f42400
                  |L16.160|
                          DCD      0x007a1200
                  |L16.164|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1519     */
;;;1520   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4601              MOV      r1,r0
;;;1521   {
;;;1522     uint32_t tmp = 0;
;;;1523     uint32_t statusreg = 0;
;;;1524     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1525   
;;;1526     /* Check the parameters */
;;;1527     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1528   
;;;1529     /* Get the RCC register index */
;;;1530     tmp = RCC_FLAG >> 5;
000004  094a              LSRS     r2,r1,#5
;;;1531   
;;;1532     if (tmp == 1)               /* The flag to check is in CR register */
000006  2a01              CMP      r2,#1
000008  d009              BEQ      |L17.30|
;;;1533     {
;;;1534       statusreg = RCC->CR;
;;;1535     }
;;;1536     else          /* The flag to check is in CSR register (tmp == 2) */
;;;1537     {
;;;1538       statusreg = RCC->CSR;
00000a  4a06              LDR      r2,|L17.36|
                  |L17.12|
00000c  6812              LDR      r2,[r2,#0]
;;;1539     }
;;;1540   
;;;1541     /* Get the flag position */
;;;1542     tmp = RCC_FLAG & FLAG_MASK;
00000e  f001011f          AND      r1,r1,#0x1f
;;;1543   
;;;1544     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000012  2301              MOVS     r3,#1
000014  408b              LSLS     r3,r3,r1
000016  4213              TST      r3,r2
000018  d000              BEQ      |L17.28|
;;;1545     {
;;;1546       bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L17.28|
;;;1547     }
;;;1548     else
;;;1549     {
;;;1550       bitstatus = RESET;
;;;1551     }
;;;1552     /* Return the flag status */
;;;1553     return bitstatus;
;;;1554   }
00001c  4770              BX       lr
                  |L17.30|
00001e  4a01              LDR      r2,|L17.36|
000020  3a34              SUBS     r2,r2,#0x34           ;1534
000022  e7f3              B        |L17.12|
;;;1555   
                          ENDP

                  |L17.36|
                          DCD      0x40023834

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1582     */
;;;1583   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L18.16|
;;;1584   {
000002  4601              MOV      r1,r0
;;;1585     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1586     /* Check the parameters */
;;;1587     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1588     
;;;1589     /* Check the status of the specified RCC interrupt */
;;;1590     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L18.14|
;;;1591     {
;;;1592       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L18.14|
;;;1593     }
;;;1594     else
;;;1595     {
;;;1596       bitstatus = RESET;
;;;1597     }
;;;1598     /* Return the RCC_IT status */
;;;1599     return  bitstatus;
;;;1600   }
00000e  4770              BX       lr
;;;1601   
                          ENDP

                  |L18.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;745      */
;;;746    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L19.12|
;;;747    {
;;;748      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;749    }
000008  4770              BX       lr
;;;750    
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;770      */
;;;771    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L20.16|
;;;772    {
;;;773      uint32_t tmpreg = 0;
;;;774      
;;;775      /* Check the parameters */
;;;776      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;777      
;;;778      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;779      
;;;780      /* Clear HPRE[3:0] bits */
;;;781      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;782      
;;;783      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;784      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;785      
;;;786      /* Store the new value */
;;;787      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;788    }
00000c  4770              BX       lr
;;;789    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;243      */
;;;244    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L21.12|
;;;245    {
;;;246      /* Check the parameters */
;;;247      assert_param(IS_RCC_HSE(RCC_HSE));
;;;248    
;;;249      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;250      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;251    
;;;252      /* Set the new HSE configuration -------------------------------------------*/
;;;253      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  7008              STRB     r0,[r1,#0]
;;;254    
;;;255    }
000008  4770              BX       lr
;;;256    
                          ENDP

00000a  0000              DCW      0x0000
                  |L21.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;419      */
;;;420    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;421    {
;;;422      /* Check the parameters */
;;;423      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;424      
;;;425      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;426    }
000004  4770              BX       lr
;;;427    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42470000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1481     */
;;;1482   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L23.20|
;;;1483   {
;;;1484     /* Check the parameters */
;;;1485     assert_param(IS_RCC_IT(RCC_IT));
;;;1486     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1487     
;;;1488     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1489     {
;;;1490       /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;1491       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;1492     }
;;;1493     else
;;;1494     {
;;;1495       /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;1496       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7811              LDRB     r1,[r2,#0]
000006  d001              BEQ      |L23.12|
000008  4301              ORRS     r1,r1,r0              ;1491
00000a  e000              B        |L23.14|
                  |L23.12|
00000c  4381              BICS     r1,r1,r0
                  |L23.14|
00000e  7011              STRB     r1,[r2,#0]            ;1491
;;;1497     }
;;;1498   }
000010  4770              BX       lr
;;;1499   
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_LSEClockSecuritySystemCmd PROC
;;;569      */
;;;570    void RCC_LSEClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L24.8|
;;;571    {
;;;572      /* Check the parameters */
;;;573      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;574      
;;;575      *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;576    }
000004  4770              BX       lr
;;;577    
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      0x424706ac

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;444      */
;;;445    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4902              LDR      r1,|L25.12|
;;;446    {
;;;447      /* Check the parameters */
;;;448      assert_param(IS_RCC_LSE(RCC_LSE));
;;;449      
;;;450      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;451      *(__IO uint8_t *) CSR_BYTE2_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;452    
;;;453      /* Set the new LSE configuration -------------------------------------------*/
;;;454      *(__IO uint8_t *) CSR_BYTE2_ADDRESS = RCC_LSE;  
000006  7008              STRB     r0,[r1,#0]
;;;455    }
000008  4770              BX       lr
;;;456    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023835

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;468      */
;;;469    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;470    {
;;;471      /* Check the parameters */
;;;472      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;473      
;;;474      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;475    }
000004  4770              BX       lr
;;;476    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42470680

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;599      */
;;;600    void RCC_MCOConfig(uint8_t RCC_MCOSource, uint8_t RCC_MCODiv)
000000  4308              ORRS     r0,r0,r1
;;;601    {
;;;602      /* Check the parameters */
;;;603      assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
;;;604      assert_param(IS_RCC_MCO_DIV(RCC_MCODiv));
;;;605        
;;;606      /* Select MCO clock source and prescaler */
;;;607      *(__IO uint8_t *) CFGR_BYTE4_ADDRESS =  RCC_MCOSource | RCC_MCODiv; 
000002  4901              LDR      r1,|L27.8|
000004  7008              STRB     r0,[r1,#0]
;;;608    }
000006  4770              BX       lr
;;;609    
                          ENDP

                  |L27.8|
                          DCD      0x4002380b

                          AREA ||i.RCC_MSICmd||, CODE, READONLY, ALIGN=2

                  RCC_MSICmd PROC
;;;367      */
;;;368    void RCC_MSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;369    {
;;;370      /* Check the parameters */
;;;371      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;372      
;;;373      *(__IO uint32_t *) CR_MSION_BB = (uint32_t)NewState;
000002  6208              STR      r0,[r1,#0x20]
;;;374    }
000004  4770              BX       lr
;;;375    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_MSIRangeConfig||, CODE, READONLY, ALIGN=2

                  RCC_MSIRangeConfig PROC
;;;329      */
;;;330    void RCC_MSIRangeConfig(uint32_t RCC_MSIRange)
000000  4a03              LDR      r2,|L29.16|
;;;331    {
;;;332      uint32_t tmpreg = 0;
;;;333      
;;;334      /* Check the parameters */
;;;335      assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_MSIRange));
;;;336      
;;;337      tmpreg = RCC->ICSCR;
000002  6811              LDR      r1,[r2,#0]
;;;338      
;;;339      /* Clear MSIRANGE[2:0] bits */
;;;340      tmpreg &= ~RCC_ICSCR_MSIRANGE;
000004  f4214160          BIC      r1,r1,#0xe000
;;;341      
;;;342      /* Set the MSIRANGE[2:0] bits according to RCC_MSIRange value */
;;;343      tmpreg |= (uint32_t)RCC_MSIRange;
000008  4301              ORRS     r1,r1,r0
;;;344    
;;;345      /* Store the new value */
;;;346      RCC->ICSCR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;347    }
00000c  4770              BX       lr
;;;348    
                          ENDP

00000e  0000              DCW      0x0000
                  |L29.16|
                          DCD      0x40023804

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;801      */
;;;802    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L30.16|
;;;803    {
;;;804      uint32_t tmpreg = 0;
;;;805      
;;;806      /* Check the parameters */
;;;807      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;808      
;;;809      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;810      
;;;811      /* Clear PPRE1[2:0] bits */
;;;812      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42161e0          BIC      r1,r1,#0x700
;;;813      
;;;814      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;815      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;816      
;;;817      /* Store the new value */
;;;818      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;819    }
00000c  4770              BX       lr
;;;820    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;832      */
;;;833    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L31.16|
;;;834    {
;;;835      uint32_t tmpreg = 0;
;;;836      
;;;837      /* Check the parameters */
;;;838      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;839      
;;;840      tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;841      
;;;842      /* Clear PPRE2[2:0] bits */
;;;843      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4225260          BIC      r2,r2,#0x3800
;;;844      
;;;845      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;846      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;847      
;;;848      /* Store the new value */
;;;849      RCC->CFGR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;850    }
00000e  4770              BX       lr
;;;851    
                          ENDP

                  |L31.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;536      */
;;;537    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;538    {
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      
;;;542      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;543    }
000004  4770              BX       lr
;;;544    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;515      */
;;;516    void RCC_PLLConfig(uint8_t RCC_PLLSource, uint8_t RCC_PLLMul, uint8_t RCC_PLLDiv)
000000  4311              ORRS     r1,r1,r2
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;520      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;521      assert_param(IS_RCC_PLL_DIV(RCC_PLLDiv));
;;;522      
;;;523      *(__IO uint8_t *) CFGR_BYTE3_ADDRESS = (uint8_t)(RCC_PLLSource | ((uint8_t)(RCC_PLLMul | (uint8_t)(RCC_PLLDiv))));
000002  4301              ORRS     r1,r1,r0
000004  4801              LDR      r0,|L33.12|
000006  7001              STRB     r1,[r0,#0]
;;;524    }
000008  4770              BX       lr
;;;525    
                          ENDP

00000a  0000              DCW      0x0000
                  |L33.12|
                          DCD      0x4002380a

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1055     */
;;;1056   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L34.8|
;;;1057   {
;;;1058     /* Check the parameters */
;;;1059     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1060     
;;;1061     *(__IO uint32_t *) CSR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1062   }
000004  4770              BX       lr
;;;1063   
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      0x424706d8

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1019     */
;;;1020   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  f3c04101          UBFX     r1,r0,#16,#2
;;;1021   {
;;;1022     uint32_t 	tmpreg = 0;
;;;1023   
;;;1024     /* Check the parameters */
;;;1025     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1026     
;;;1027     if ((RCC_RTCCLKSource & RCC_CSR_RTCSEL_HSE) == RCC_CSR_RTCSEL_HSE)
000004  2903              CMP      r1,#3
000006  d107              BNE      |L35.24|
;;;1028     { 
;;;1029       /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;1030       tmpreg = RCC->CR;
000008  4a09              LDR      r2,|L35.48|
00000a  6811              LDR      r1,[r2,#0]
;;;1031   
;;;1032       /* Clear RTCPRE[1:0] bits */
;;;1033       tmpreg &= ~RCC_CR_RTCPRE;
00000c  f02143c0          BIC      r3,r1,#0x60000000
;;;1034   
;;;1035       /* Configure HSE division factor for RTC clock */
;;;1036       tmpreg |= (RCC_RTCCLKSource & RCC_CR_RTCPRE);
000010  f00041c0          AND      r1,r0,#0x60000000
000014  4319              ORRS     r1,r1,r3
;;;1037   
;;;1038       /* Store the new value */
;;;1039       RCC->CR = tmpreg;
000016  6011              STR      r1,[r2,#0]
                  |L35.24|
;;;1040     }
;;;1041            
;;;1042     RCC->CSR &= ~RCC_CSR_RTCSEL;
000018  4905              LDR      r1,|L35.48|
00001a  3134              ADDS     r1,r1,#0x34
00001c  680a              LDR      r2,[r1,#0]
00001e  f4223240          BIC      r2,r2,#0x30000
000022  600a              STR      r2,[r1,#0]
;;;1043     
;;;1044     /* Select the RTC clock source */
;;;1045     RCC->CSR |= (RCC_RTCCLKSource & RCC_CSR_RTCSEL);
000024  680a              LDR      r2,[r1,#0]
000026  f4003040          AND      r0,r0,#0x30000
00002a  4302              ORRS     r2,r2,r0
00002c  600a              STR      r2,[r1,#0]
;;;1046   }
00002e  4770              BX       lr
;;;1047   
                          ENDP

                  |L35.48|
                          DCD      0x40023800

                          AREA ||i.RCC_RTCResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCResetCmd PROC
;;;1071     */
;;;1072   void RCC_RTCResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L36.8|
;;;1073   {
;;;1074     /* Check the parameters */
;;;1075     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1076     
;;;1077     *(__IO uint32_t *) CSR_RTCRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1078   }
000004  4770              BX       lr
;;;1079   
                          ENDP

000006  0000              DCW      0x0000
                  |L36.8|
                          DCD      0x424706dc

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;716      */
;;;717    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L37.16|
;;;718    {
;;;719      uint32_t tmpreg = 0;
;;;720      
;;;721      /* Check the parameters */
;;;722      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;723      
;;;724      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;725      
;;;726      /* Clear SW[1:0] bits */
;;;727      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;728      
;;;729      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;730      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;731      
;;;732      /* Store the new value */
;;;733      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;734    }
00000c  4770              BX       lr
;;;735    
                          ENDP

00000e  0000              DCW      0x0000
                  |L37.16|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;268      */
;;;269    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;270    {
;;;271      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
;;;272      ErrorStatus status = ERROR;
;;;273      FlagStatus HSEStatus = RESET;
;;;274      
;;;275      /* Wait till HSE is ready and if timeout is reached exit */
;;;276      do
;;;277      {
;;;278        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;279        StartUpCounter++;  
;;;280      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L38.10|
00000a  2031              MOVS     r0,#0x31              ;278
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;279
000012  1c49              ADDS     r1,r1,#1              ;279
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L38.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L38.10|
                  |L38.30|
;;;281      
;;;282      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L38.42|
;;;283      {
;;;284        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L38.42|
;;;285      }
;;;286      else
;;;287      {
;;;288        status = ERROR;
;;;289      }  
;;;290      return (status);
;;;291    }
00002a  bd18              POP      {r3,r4,pc}
;;;292    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  PLLMulTable
000000  03040608          DCB      0x03,0x04,0x06,0x08
000004  0c101820          DCB      0x0c,0x10,0x18,0x20
000008  30                DCB      0x30
                  APBAHBPrescTable
000009  000000            DCB      0x00,0x00,0x00
00000c  00010203          DCB      0x00,0x01,0x02,0x03
000010  04010203          DCB      0x04,0x01,0x02,0x03
000014  04060708          DCB      0x04,0x06,0x07,0x08
000018  09                DCB      0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_rcc_c_49e27980____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_rcc_c_49e27980____REVSH|
#line 144
|__asm___15_stm32l1xx_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
