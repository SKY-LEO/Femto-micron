; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_syscfg.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_syscfg.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_syscfg.crf ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_syscfg.c]
                          THUMB

                          AREA ||i.SYSCFG_DeInit||, CODE, READONLY, ALIGN=1

                  SYSCFG_DeInit PROC
;;;113      */
;;;114    void SYSCFG_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;115    {
;;;116       RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;117       RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2001              MOVS     r0,#1
000012  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;118    }
;;;119    
                          ENDP


                          AREA ||i.SYSCFG_EXTILineConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_EXTILineConfig PROC
;;;199      */
;;;200    void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202      uint32_t tmp = 0x00;
;;;203    
;;;204      /* Check the parameters */
;;;205      assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
;;;206      assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
;;;207      
;;;208      tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
000002  078a              LSLS     r2,r1,#30
;;;209      SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
000004  f0210403          BIC      r4,r1,#3
000008  4906              LDR      r1,|L2.36|
00000a  0f13              LSRS     r3,r2,#28             ;208
00000c  4421              ADD      r1,r1,r4
00000e  220f              MOVS     r2,#0xf               ;208
000010  688c              LDR      r4,[r1,#8]
000012  409a              LSLS     r2,r2,r3              ;208
000014  4394              BICS     r4,r4,r2
000016  608c              STR      r4,[r1,#8]
;;;210      SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
000018  688a              LDR      r2,[r1,#8]
00001a  4098              LSLS     r0,r0,r3
00001c  4302              ORRS     r2,r2,r0
00001e  608a              STR      r2,[r1,#8]
;;;211    }
000020  bd10              POP      {r4,pc}
;;;212    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_GetBootMode||, CODE, READONLY, ALIGN=2

                  SYSCFG_GetBootMode PROC
;;;162      */
;;;163    uint32_t SYSCFG_GetBootMode(void)
000000  4802              LDR      r0,|L3.12|
;;;164    {
;;;165      return (SYSCFG->MEMRMP & SYSCFG_MEMRMP_BOOT_MODE);
000002  6800              LDR      r0,[r0,#0]
000004  f4007040          AND      r0,r0,#0x300
;;;166    }
000008  4770              BX       lr
;;;167    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_MemoryRemapConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_MemoryRemapConfig PROC
;;;145      */
;;;146    void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
000000  4901              LDR      r1,|L4.8|
;;;147    {
;;;148      /* Check the parameters */
;;;149      assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));
;;;150      SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
000002  6008              STR      r0,[r1,#0]
;;;151    }
000004  4770              BX       lr
;;;152    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x40010000

                          AREA ||i.SYSCFG_RIChannelSpeedConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_RIChannelSpeedConfig PROC
;;;387      */
;;;388    void SYSCFG_RIChannelSpeedConfig(uint32_t RI_Channel, uint32_t RI_ChannelSpeed)
000000  4a04              LDR      r2,|L5.20|
;;;389    {
;;;390      /* Check the parameters */
;;;391      assert_param(IS_RI_CHANNEL(RI_Channel));
;;;392      assert_param(IS_RI_CHANNELSPEED(RI_ChannelSpeed));
;;;393    
;;;394      if(RI_ChannelSpeed != RI_ChannelSpeed_Fast)
000002  2900              CMP      r1,#0
;;;395      {
;;;396        /* Set the selected channel as a slow ADC channel */
;;;397        COMP->CSR &= (uint32_t) (~RI_Channel);
;;;398      }
;;;399      else
;;;400      {
;;;401        /* Set the selected channel as a fast ADC channel */
;;;402        COMP->CSR |= (uint32_t) (RI_Channel);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4381              BICS     r1,r1,r0              ;397
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4301              ORRS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;397
;;;403      }
;;;404    }
000010  4770              BX       lr
;;;405    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40007c00

                          AREA ||i.SYSCFG_RIDeInit||, CODE, READONLY, ALIGN=2

                  SYSCFG_RIDeInit PROC
;;;124      */
;;;125    void SYSCFG_RIDeInit(void)
000000  4907              LDR      r1,|L6.32|
;;;126    {
;;;127      RI->ICR     = ((uint32_t)0x00000000);    /*!< Set RI->ICR to reset value */
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]
;;;128      RI->ASCR1   = ((uint32_t)0x00000000);    /*!< Set RI->ASCR1 to reset value */
000006  1d09              ADDS     r1,r1,#4
000008  6008              STR      r0,[r1,#0]
;;;129      RI->ASCR2   = ((uint32_t)0x00000000);    /*!< Set RI->ASCR2 to reset value */
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;130      RI->HYSCR1  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR1 to reset value */
00000e  1d09              ADDS     r1,r1,#4
000010  6008              STR      r0,[r1,#0]
;;;131      RI->HYSCR2  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR2 to reset value */
000012  1d09              ADDS     r1,r1,#4
000014  6008              STR      r0,[r1,#0]
;;;132      RI->HYSCR3  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR3 to reset value */
000016  1d09              ADDS     r1,r1,#4
000018  6008              STR      r0,[r1,#0]
;;;133      RI->HYSCR4  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR4 to reset value */
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
;;;134    }
00001e  4770              BX       lr
;;;135    
                          ENDP

                  |L6.32|
                          DCD      0x40007c04

                          AREA ||i.SYSCFG_RIHysteresisConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_RIHysteresisConfig PROC
;;;530      */
;;;531    void SYSCFG_RIHysteresisConfig(uint8_t RI_Port, uint16_t RI_Pin,
000000  b510              PUSH     {r4,lr}
;;;532                                 FunctionalState NewState)
;;;533    {
;;;534      /* Check the parameters */
;;;535      assert_param(IS_RI_PORT(RI_Port));
;;;536      assert_param(IS_RI_PIN(RI_Pin));
;;;537      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;538      
;;;539      if(RI_Port == RI_PortA)
;;;540      {  
;;;541        if (NewState != DISABLE)
;;;542        {
;;;543          /* Hysteresis on */
;;;544          RI->HYSCR1 &= (uint32_t)~((uint32_t)RI_Pin);
000002  4b14              LDR      r3,|L7.84|
000004  2801              CMP      r0,#1                 ;539
000006  d012              BEQ      |L7.46|
;;;545        }
;;;546        else
;;;547        {
;;;548          /* Hysteresis off */
;;;549          RI->HYSCR1 |= (uint32_t) RI_Pin;
;;;550        }
;;;551      }
;;;552      
;;;553      else if(RI_Port == RI_PortB)
;;;554      {
;;;555      
;;;556        if (NewState != DISABLE)
;;;557        {
;;;558          /* Hysteresis on */
;;;559          RI->HYSCR1 &= (uint32_t) (~((uint32_t)RI_Pin) << 16);
000008  43cc              MVNS     r4,r1
00000a  2802              CMP      r0,#2                 ;553
00000c  d014              BEQ      |L7.56|
;;;560        }
;;;561        else
;;;562        {
;;;563          /* Hysteresis off */
;;;564          RI->HYSCR1 |= (uint32_t) ((uint32_t)(RI_Pin) << 16);
;;;565        }
;;;566      }  
;;;567     
;;;568      else if(RI_Port == RI_PortC)
;;;569      {
;;;570      
;;;571        if (NewState != DISABLE)
;;;572        {
;;;573          /* Hysteresis on */
;;;574          RI->HYSCR2 &= (uint32_t) (~((uint32_t)RI_Pin));
00000e  1d1b              ADDS     r3,r3,#4
000010  2803              CMP      r0,#3                 ;568
000012  d00c              BEQ      |L7.46|
;;;575        }
;;;576        else
;;;577        {
;;;578          /* Hysteresis off */
;;;579          RI->HYSCR2 |= (uint32_t) (RI_Pin );
;;;580        }
;;;581      } 
;;;582      else if(RI_Port == RI_PortD)
000014  2804              CMP      r0,#4
000016  d00f              BEQ      |L7.56|
;;;583      {
;;;584        if (NewState != DISABLE)
;;;585        {
;;;586          /* Hysteresis on */
;;;587          RI->HYSCR2 &= (uint32_t) (~((uint32_t)RI_Pin) << 16);
;;;588        }
;;;589        else
;;;590        {
;;;591          /* Hysteresis off */
;;;592          RI->HYSCR2 |= (uint32_t) ((uint32_t)(RI_Pin) << 16);
;;;593    
;;;594        }
;;;595      }
;;;596      else if(RI_Port == RI_PortE)
;;;597      {
;;;598        if (NewState != DISABLE)
;;;599        {
;;;600          /* Hysteresis on */
;;;601          RI->HYSCR3 &= (uint32_t) (~((uint32_t)RI_Pin));
000018  1d1b              ADDS     r3,r3,#4
00001a  2805              CMP      r0,#5                 ;596
00001c  d007              BEQ      |L7.46|
;;;602        }
;;;603        else
;;;604        {
;;;605          /* Hysteresis off */
;;;606          RI->HYSCR3 |= (uint32_t) (RI_Pin );
;;;607        }
;;;608      }
;;;609      else if(RI_Port == RI_PortF)
00001e  2806              CMP      r0,#6
000020  d00a              BEQ      |L7.56|
;;;610      {
;;;611        if (NewState != DISABLE)
;;;612        {
;;;613          /* Hysteresis on */
;;;614          RI->HYSCR3 &= (uint32_t) (~((uint32_t)RI_Pin) << 16);
;;;615        }
;;;616        else
;;;617        {
;;;618          /* Hysteresis off */
;;;619          RI->HYSCR3 |= (uint32_t) ((uint32_t)(RI_Pin) << 16);
;;;620        }
;;;621      }
;;;622      else /* RI_Port == RI_PortG */
;;;623      {
;;;624        if (NewState != DISABLE)
;;;625        {
;;;626          /* Hysteresis on */
;;;627          RI->HYSCR4 &= (uint32_t) (~((uint32_t)RI_Pin));
000022  1d18              ADDS     r0,r3,#4
000024  2a00              CMP      r2,#0                 ;624
;;;628        }
;;;629        else
;;;630        {
;;;631          /* Hysteresis off */
;;;632          RI->HYSCR4 |= (uint32_t) (RI_Pin);
000026  6802              LDR      r2,[r0,#0]
000028  d010              BEQ      |L7.76|
00002a  438a              BICS     r2,r2,r1              ;627
00002c  e00f              B        |L7.78|
                  |L7.46|
00002e  6818              LDR      r0,[r3,#0]            ;606
000030  b13a              CBZ      r2,|L7.66|
000032  4388              BICS     r0,r0,r1              ;601
                  |L7.52|
000034  6018              STR      r0,[r3,#0]            ;549
;;;633        }
;;;634      }
;;;635    }
000036  bd10              POP      {r4,pc}
                  |L7.56|
000038  6818              LDR      r0,[r3,#0]            ;619
00003a  b122              CBZ      r2,|L7.70|
00003c  ea004004          AND      r0,r0,r4,LSL #16      ;614
000040  e7f8              B        |L7.52|
                  |L7.66|
000042  4308              ORRS     r0,r0,r1              ;606
000044  e7f6              B        |L7.52|
                  |L7.70|
000046  ea404001          ORR      r0,r0,r1,LSL #16      ;619
00004a  e7f3              B        |L7.52|
                  |L7.76|
00004c  430a              ORRS     r2,r2,r1              ;632
                  |L7.78|
00004e  6002              STR      r2,[r0,#0]            ;632
000050  bd10              POP      {r4,pc}
;;;636    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      0x40007c10

                          AREA ||i.SYSCFG_RIIOSwitchConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_RIIOSwitchConfig PROC
;;;435      */
;;;436    void SYSCFG_RIIOSwitchConfig(uint32_t RI_IOSwitch, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;437    {
;;;438      uint32_t ioswitchmask = 0;
;;;439      
;;;440      /* Check the parameters */
;;;441      assert_param(IS_RI_IOSWITCH(RI_IOSwitch));
;;;442      
;;;443      /* Read Analog switch register index */
;;;444      ioswitchmask = RI_IOSwitch >> 31;
000002  0fc4              LSRS     r4,r0,#31
;;;445      
;;;446      /* Get Bits[30:0] of the IO switch */
;;;447      RI_IOSwitch  &= 0x7FFFFFFF;
000004  f0204200          BIC      r2,r0,#0x80000000
;;;448      
;;;449      
;;;450      if (NewState != DISABLE)
;;;451      {
;;;452        if (ioswitchmask != 0)
;;;453        {
;;;454          /* Close the analog switches */
;;;455          RI->ASCR1 |= RI_IOSwitch;
000008  4809              LDR      r0,|L8.48|
;;;456        }
;;;457        else
;;;458        {
;;;459          /* Open the analog switches */
;;;460          RI->ASCR2 |= RI_IOSwitch;
00000a  1d03              ADDS     r3,r0,#4
00000c  b131              CBZ      r1,|L8.28|
00000e  b114              CBZ      r4,|L8.22|
000010  6801              LDR      r1,[r0,#0]            ;455
000012  4311              ORRS     r1,r1,r2              ;455
000014  e005              B        |L8.34|
                  |L8.22|
000016  6818              LDR      r0,[r3,#0]
000018  4310              ORRS     r0,r0,r2
00001a  e006              B        |L8.42|
                  |L8.28|
;;;461        }
;;;462      }
;;;463      else
;;;464      {
;;;465        if (ioswitchmask != 0)
00001c  b11c              CBZ      r4,|L8.38|
;;;466        {
;;;467          /* Close the analog switches */
;;;468          RI->ASCR1 &= (~ (uint32_t)RI_IOSwitch);
00001e  6801              LDR      r1,[r0,#0]
000020  4391              BICS     r1,r1,r2
                  |L8.34|
000022  6001              STR      r1,[r0,#0]            ;455
;;;469        }
;;;470        else
;;;471        {
;;;472          /* Open the analog switches */
;;;473          RI->ASCR2 &= (~ (uint32_t)RI_IOSwitch);
;;;474        }
;;;475      }
;;;476    }
000024  bd10              POP      {r4,pc}
                  |L8.38|
000026  6818              LDR      r0,[r3,#0]            ;473
000028  4390              BICS     r0,r0,r2              ;473
                  |L8.42|
00002a  6018              STR      r0,[r3,#0]            ;460
00002c  bd10              POP      {r4,pc}
;;;477    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x40007c08

                          AREA ||i.SYSCFG_RIResistorConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_RIResistorConfig PROC
;;;356      */
;;;357    void SYSCFG_RIResistorConfig(uint32_t RI_Resistor, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;358    {
;;;359      /* Check the parameters */
;;;360      assert_param(IS_RI_RESISTOR(RI_Resistor));
;;;361      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;362      
;;;363      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;364      {
;;;365        /* Enable the resistor */
;;;366        COMP->CSR |= (uint32_t) RI_Resistor;
;;;367      }
;;;368      else
;;;369      {
;;;370        /* Disable the Resistor */
;;;371        COMP->CSR &= (uint32_t) (~RI_Resistor);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;366
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;366
;;;372      }
;;;373    }
000010  4770              BX       lr
;;;374    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40007c00

                          AREA ||i.SYSCFG_RISwitchControlModeCmd||, CODE, READONLY, ALIGN=2

                  SYSCFG_RISwitchControlModeCmd PROC
;;;490      */
;;;491    void SYSCFG_RISwitchControlModeCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L10.24|
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;495      
;;;496      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;497      {
;;;498        /* Enable the Switch control mode */
;;;499        RI->ASCR1 |= (uint32_t) RI_ASCR1_SCM;
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable the Switch control mode */
;;;504        RI->ASCR1 &= (uint32_t)(~RI_ASCR1_SCM);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L10.14|
000008  f0404000          ORR      r0,r0,#0x80000000     ;499
00000c  e001              B        |L10.18|
                  |L10.14|
00000e  f0204000          BIC      r0,r0,#0x80000000
                  |L10.18|
000012  6008              STR      r0,[r1,#0]            ;499
;;;505      }
;;;506    }
000014  4770              BX       lr
;;;507    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40007c08

                          AREA ||i.SYSCFG_RITIMInputCaptureConfig||, CODE, READONLY, ALIGN=2

                  SYSCFG_RITIMInputCaptureConfig PROC
;;;285      */
;;;286    void SYSCFG_RITIMInputCaptureConfig(uint32_t RI_InputCapture, uint32_t RI_InputCaptureRouting)
000000  4b0e              LDR      r3,|L11.60|
;;;287    {
000002  b510              PUSH     {r4,lr}
;;;288      uint32_t tmpreg = 0;
;;;289    
;;;290      /* Check the parameters */
;;;291      assert_param(IS_RI_INPUTCAPTURE(RI_InputCapture));
;;;292      assert_param(IS_RI_INPUTCAPTURE_ROUTING(RI_InputCaptureRouting));
;;;293    
;;;294      /* Get the old register value */
;;;295      tmpreg = RI->ICR;
000004  681a              LDR      r2,[r3,#0]
;;;296    
;;;297      /* Select input captures to be routed */
;;;298      tmpreg |= (RI_InputCapture);
000006  4302              ORRS     r2,r2,r0
;;;299    
;;;300      if((RI_InputCapture & RI_InputCapture_IC1) == RI_InputCapture_IC1)
000008  0344              LSLS     r4,r0,#13
00000a  d502              BPL      |L11.18|
;;;301      {
;;;302        /* Clear the input capture select bits */
;;;303        tmpreg &= (uint32_t)(~IC_ROUTING_MASK);
00000c  f022020f          BIC      r2,r2,#0xf
;;;304    
;;;305        /* Set RI_InputCaptureRouting bits  */
;;;306        tmpreg |= (uint32_t)( RI_InputCaptureRouting);
000010  430a              ORRS     r2,r2,r1
                  |L11.18|
;;;307      }
;;;308    
;;;309      if((RI_InputCapture & RI_InputCapture_IC2) == RI_InputCapture_IC2)
000012  0304              LSLS     r4,r0,#12
000014  d503              BPL      |L11.30|
;;;310      {
;;;311        /* Clear the input capture select bits */
;;;312        tmpreg &= (uint32_t)(~(IC_ROUTING_MASK << 4));
000016  f02202f0          BIC      r2,r2,#0xf0
;;;313    
;;;314        /* Set RI_InputCaptureRouting bits  */
;;;315        tmpreg |= (uint32_t)( (RI_InputCaptureRouting << 4));
00001a  ea421201          ORR      r2,r2,r1,LSL #4
                  |L11.30|
;;;316      }
;;;317    
;;;318      if((RI_InputCapture & RI_InputCapture_IC3) == RI_InputCapture_IC3)
00001e  02c4              LSLS     r4,r0,#11
000020  d503              BPL      |L11.42|
;;;319      {
;;;320        /* Clear the input capture select bits */
;;;321        tmpreg &= (uint32_t)(~(IC_ROUTING_MASK << 8));
000022  f4226270          BIC      r2,r2,#0xf00
;;;322    
;;;323        /* Set RI_InputCaptureRouting bits  */
;;;324        tmpreg |= (uint32_t)( (RI_InputCaptureRouting << 8));
000026  ea422201          ORR      r2,r2,r1,LSL #8
                  |L11.42|
;;;325      }
;;;326    
;;;327      if((RI_InputCapture & RI_InputCapture_IC4) == RI_InputCapture_IC4)
00002a  0280              LSLS     r0,r0,#10
00002c  d503              BPL      |L11.54|
;;;328      {
;;;329        /* Clear the input capture select bits */
;;;330        tmpreg &= (uint32_t)(~(IC_ROUTING_MASK << 12));
00002e  f4224070          BIC      r0,r2,#0xf000
;;;331    
;;;332        /* Set RI_InputCaptureRouting bits  */
;;;333        tmpreg |= (uint32_t)( (RI_InputCaptureRouting << 12));
000032  ea403201          ORR      r2,r0,r1,LSL #12
                  |L11.54|
;;;334      }
;;;335    
;;;336      /* Write to RI->ICR register */
;;;337      RI->ICR = tmpreg;
000036  601a              STR      r2,[r3,#0]
;;;338    }
000038  bd10              POP      {r4,pc}
;;;339    
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      0x40007c04

                          AREA ||i.SYSCFG_RITIMSelect||, CODE, READONLY, ALIGN=2

                  SYSCFG_RITIMSelect PROC
;;;240      */
;;;241    void SYSCFG_RITIMSelect(uint32_t TIM_Select)
000000  4a03              LDR      r2,|L12.16|
;;;242    {
;;;243      uint32_t tmpreg = 0;
;;;244    
;;;245      /* Check the parameters */
;;;246      assert_param(IS_RI_TIM(TIM_Select));
;;;247    
;;;248      /* Get the old register value */
;;;249      tmpreg = RI->ICR;
000002  6811              LDR      r1,[r2,#0]
;;;250    
;;;251      /* Clear the TIMx select bits */
;;;252      tmpreg &= TIM_SELECT_MASK;
000004  f4213140          BIC      r1,r1,#0x30000
;;;253    
;;;254      /* Select the Timer */
;;;255      tmpreg |= (TIM_Select);
000008  4301              ORRS     r1,r1,r0
;;;256    
;;;257      /* Write to RI->ICR register */
;;;258      RI->ICR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;259    }
00000c  4770              BX       lr
;;;260    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x40007c04

                          AREA ||i.SYSCFG_USBPuCmd||, CODE, READONLY, ALIGN=2

                  SYSCFG_USBPuCmd PROC
;;;174      */
;;;175    void SYSCFG_USBPuCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L13.24|
;;;176    {
;;;177      /* Check the parameters */
;;;178      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;179    
;;;180      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;181      {
;;;182        /* Connect internal pull-up on USB DP line */
;;;183        SYSCFG->PMC |= (uint32_t) SYSCFG_PMC_USB_PU;
;;;184      }
;;;185      else
;;;186      {
;;;187        /* Disconnect internal pull-up on USB DP line */
;;;188        SYSCFG->PMC &= (uint32_t)(~SYSCFG_PMC_USB_PU);
000004  6848              LDR      r0,[r1,#4]
000006  d002              BEQ      |L13.14|
000008  f0400001          ORR      r0,r0,#1              ;183
00000c  e001              B        |L13.18|
                  |L13.14|
00000e  f0200001          BIC      r0,r0,#1
                  |L13.18|
000012  6048              STR      r0,[r1,#4]            ;183
;;;189      }
;;;190    }
000014  4770              BX       lr
;;;191    
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      0x40010000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_syscfg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32l1xx_syscfg_c_57637610____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_stm32l1xx_syscfg_c_57637610____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32l1xx_syscfg_c_57637610____REVSH|
#line 144
|__asm___18_stm32l1xx_syscfg_c_57637610____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
