; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\hw_config.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.DFU_Button_Config||, CODE, READONLY, ALIGN=2

                  DFU_Button_Config PROC
;;;253    *******************************************************************************/
;;;254    void DFU_Button_Config(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;255    { 
;;;256      GPIO_InitTypeDef   GPIO_InitStructure;
;;;257    
;;;258      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE); // Подаем тактирование на порт
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;259      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;        // Режим ножки "вход"
00000a  2000              MOVS     r0,#0
00000c  f88d0004          STRB     r0,[sp,#4]
;;;260      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;        // Подтяжка к +
000010  2001              MOVS     r0,#1
000012  f88d0007          STRB     r0,[sp,#7]
;;;261      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;           // Номер ножки в порту
;;;262      GPIO_Init(GPIOB, &GPIO_InitStructure);              // записиваем конфигурацию
000016  9000              STR      r0,[sp,#0]
000018  4669              MOV      r1,sp
00001a  4802              LDR      r0,|L1.36|
00001c  f7fffffe          BL       GPIO_Init
;;;263    }
000020  bd1c              POP      {r2-r4,pc}
;;;264    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40020400

                          AREA ||i.DFU_Button_Read||, CODE, READONLY, ALIGN=2

                  DFU_Button_Read PROC
;;;271    *******************************************************************************/
;;;272    uint8_t DFU_Button_Read (void)
000000  2101              MOVS     r1,#1
;;;273    {
;;;274    return GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0);
000002  4801              LDR      r0,|L2.8|
000004  f7ffbffe          B.W      GPIO_ReadInputDataBit
;;;275    }
;;;276    
                          ENDP

                  |L2.8|
                          DCD      0x40020400

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;185    *******************************************************************************/
;;;186    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L3.8|
;;;187    {
;;;188      /* Set the device state to suspend */
;;;189      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;190    }
000006  4770              BX       lr
;;;191    
                          ENDP

                  |L3.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;354    *******************************************************************************/
;;;355    void Get_SerialNum(void)
000000  4809              LDR      r0,|L4.40|
;;;356    {
000002  b510              PUSH     {r4,lr}
;;;357      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;358    
;;;359      Device_Serial0 = *(uint32_t*)ID1;
000004  e9d01414          LDRD     r1,r4,[r0,#0x50]
;;;360      Device_Serial1 = *(uint32_t*)ID2;
;;;361      Device_Serial2 = *(uint32_t*)ID3;   
000008  6e40              LDR      r0,[r0,#0x64]
;;;362    
;;;363      Device_Serial0 += Device_Serial2;
00000a  1808              ADDS     r0,r1,r0
00000c  d00b              BEQ      |L4.38|
;;;364    
;;;365      if (Device_Serial0 != 0)
;;;366      {
;;;367        IntToUnicode (Device_Serial0, &DFU_StringSerial[2] , 8);
00000e  2208              MOVS     r2,#8
000010  4906              LDR      r1,|L4.44|
000012  f7fffffe          BL       IntToUnicode
;;;368        IntToUnicode (Device_Serial1, &DFU_StringSerial[18], 4);
000016  4905              LDR      r1,|L4.44|
000018  4620              MOV      r0,r4
00001a  2204              MOVS     r2,#4
00001c  e8bd4010          POP      {r4,lr}
000020  3110              ADDS     r1,r1,#0x10
000022  f7ffbffe          B.W      IntToUnicode
                  |L4.38|
;;;369      }
;;;370    }
000026  bd10              POP      {r4,pc}
;;;371    
                          ENDP

                  |L4.40|
                          DCD      0x1ff80000
                  |L4.44|
                          DCD      DFU_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;378    *******************************************************************************/
;;;379    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;380    {
;;;381      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;382      
;;;383      for( idx = 0 ; idx < len ; idx ++)
;;;384      {
;;;385        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;386        {
;;;387          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;388        }
;;;389        else
;;;390        {
;;;391          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L5.50|
00000e  bf00              NOP                            ;385
                  |L5.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;385
000014  d902              BLS      |L5.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;387
00001a  e001              B        |L5.32|
                  |L5.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L5.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;392        }
;;;393        
;;;394        value = value << 4;
;;;395        
;;;396        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;394
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;383
                  |L5.50|
000032  4293              CMP      r3,r2                 ;383
000034  d3ec              BCC      |L5.16|
;;;397      }
;;;398    }
000036  bdf0              POP      {r4-r7,pc}
;;;399    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;198    *******************************************************************************/
;;;199    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L6.20|
;;;200    {
;;;201      DEVICE_INFO *pInfo = &Device_Info;
;;;202    
;;;203      /* Set the device state to the correct state */
;;;204      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;205      {
;;;206        /* Device configured */
;;;207        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L6.24|
000006  b109              CBZ      r1,|L6.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L6.14|
                  |L6.12|
;;;208      }
;;;209      else
;;;210      {
;;;211        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L6.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;212      }
;;;213      /*Enable SystemCoreClock*/
;;;214      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;215    }
;;;216    
                          ENDP

                  |L6.20|
                          DCD      Device_Info
                  |L6.24|
                          DCD      bDeviceState

                          AREA ||i.Reset_Device||, CODE, READONLY, ALIGN=2

                  Reset_Device PROC
;;;341    *******************************************************************************/
;;;342    void Reset_Device(void)
000000  2000              MOVS     r0,#0
;;;343    {
;;;344      USB_Cable_Config(DISABLE);
000002  f7fffffe          BL       USB_Cable_Config
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L7.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L7.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L7.28|
00001c  e7fe              B        |L7.28|
;;;345      NVIC_SystemReset();
;;;346    }
;;;347    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0xe000ed0c
                  |L7.36|
                          DCD      0x05fa0004

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;54     *******************************************************************************/
;;;55     void Set_System(void)
000000  b510              PUSH     {r4,lr}
;;;56     {
;;;57     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined (STM32L1XX_MD_PLUS)
;;;58       GPIO_InitTypeDef GPIO_InitStructure;
;;;59     #endif /* STM32L1XX_XD*/
;;;60       
;;;61     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;62       GPIO_InitTypeDef  GPIO_InitStructure;
;;;63     #endif /* USB_USE_EXTERNAL_PULLUP */ 
;;;64       
;;;65       /*!< At this stage the microcontroller clock setting is already configured, 
;;;66            this is done through SystemInit() function which is called from startup
;;;67            file (startup_stm32f10x_xx.s) before to branch to application main.
;;;68            To reconfigure the default setting of SystemInit() function, refer to
;;;69            system_stm32f10x.c file
;;;70          */ 
;;;71       
;;;72     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS) || defined(STM32F37X) || defined(STM32F30X)
;;;73       /* Enable the SYSCFG module clock */
;;;74       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;75     #endif /* STM32L1XX_XD */ 
;;;76        
;;;77     FLASH_Unlock();
00000a  f7fffffe          BL       FLASH_Unlock
;;;78       
;;;79     #ifdef USE_STM3210E_EVAL
;;;80       /* Enable the FSMC Clock */
;;;81       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
;;;82     #endif /* USE_STM3210E_EVAL */
;;;83     #if defined (USE_STM3210E_EVAL)
;;;84       /* Enable the FSMC Clock */
;;;85       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
;;;86     #endif /* USE_STM3210E_EVAL */
;;;87         
;;;88     #if defined(STM32F37X) || defined(STM32F30X)
;;;89       /* Enable the USB disconnect GPIO clock */
;;;90       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;91     
;;;92      /*Set PA11,12 as IN - USB_DM,DP*/
;;;93       
;;;94       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;95       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;96       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;97       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;98       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;99       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;100      GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;101        
;;;102      /*SET PA11,12 for USB: USB_DM,DP*/
;;;103      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;104      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;105     
;;;106      /* USB_DISCONNECT used as USB pull-up */
;;;107      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;108      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;109      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;110      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;111      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;112      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;113      
;;;114     /*Output low level on USB_Disconnect Pin to enable 1.5k ohm pull-up resistor*/
;;;115      GPIO_WriteBit(USB_DISCONNECT, USB_DISCONNECT_PIN, Bit_RESET);
;;;116    
;;;117    #endif /* STM32F37X && STM32F30X */
;;;118    
;;;119    #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)  && !defined(STM32F37X) && !defined(STM32F30X)
;;;120      /* Enable "DISCONNECT" GPIO clock */
;;;121      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
;;;122    
;;;123      /* Configure USB pull-up */
;;;124      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;125      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;126      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
;;;127      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;128    
;;;129      /* Disable the USB connection till initialization phase end */  
;;;130      USB_Cable_Config(DISABLE);
;;;131    #endif /* STM32L1XX_XD */
;;;132    
;;;133    #if defined(USB_USE_EXTERNAL_PULLUP)
;;;134      /* Enable the USB disconnect GPIO clock */
;;;135      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;136    
;;;137      /* USB_DISCONNECT used as USB pull-up */
;;;138      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;139      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;140      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;141      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;142      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;143      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;144    #endif /* USB_USE_EXTERNAL_PULLUP */
;;;145      
;;;146      /* Init the media interface */
;;;147      MAL_Init();
00000e  f7fffffe          BL       MAL_Init
;;;148      USB_Cable_Config(ENABLE);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       USB_Cable_Config
;;;149      
;;;150          /* Configure the EXTI line 18 connected internally to the USB IP */
;;;151      EXTI_ClearITPendingBit(EXTI_Line18);
000018  f44f2480          MOV      r4,#0x40000
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;152      EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000022  4905              LDR      r1,|L8.56|
;;;153      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000024  2008              MOVS     r0,#8
000026  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
000028  7148              STRB     r0,[r1,#5]
;;;154      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00002a  2001              MOVS     r0,#1
00002c  7188              STRB     r0,[r1,#6]
;;;155      EXTI_Init(&EXTI_InitStructure);
00002e  e8bd4010          POP      {r4,lr}
000032  4608              MOV      r0,r1
000034  f7ffbffe          B.W      EXTI_Init
;;;156    }
;;;157    
                          ENDP

                  |L8.56|
                          DCD      ||area_number.15||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;164    *******************************************************************************/
;;;165    void Set_USBClock(void)
000000  2101              MOVS     r1,#1
;;;166    {
;;;167    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;168      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000002  05c8              LSLS     r0,r1,#23
000004  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;169       
;;;170    #else 
;;;171      /* Select USBCLK source */
;;;172      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
;;;173      
;;;174      /* Enable the USB clock */
;;;175      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;176    #endif /* STM32L1XX_MD */
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=1

                  USB_Cable_Config PROC
;;;223    *******************************************************************************/
;;;224    void USB_Cable_Config (FunctionalState NewState)
000000  b100              CBZ      r0,|L10.4|
;;;225    {
;;;226    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;227      if (NewState != DISABLE)
;;;228      {
;;;229        STM32L15_USB_CONNECT;
000002  2001              MOVS     r0,#1
                  |L10.4|
;;;230      }
;;;231      else
;;;232      {
;;;233        STM32L15_USB_DISCONNECT;
000004  f7ffbffe          B.W      SYSCFG_USBPuCmd
;;;234      }  
;;;235    #else 
;;;236      if (NewState != DISABLE)
;;;237      {
;;;238        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;239      }
;;;240      else
;;;241      {
;;;242        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
;;;243      }
;;;244    #endif /* STM32L1XX_XD */
;;;245    }
;;;246    
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;283    *******************************************************************************/
;;;284    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;285    {
;;;286      NVIC_InitTypeDef NVIC_InitStructure;
;;;287    
;;;288      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;289      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;290      
;;;291    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;292      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;293      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;294      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;295      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;296      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;297      
;;;298        /* Enable the USB Wake-up interrupt */
;;;299      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;300      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;301      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;302      NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;303      
;;;304    #elif defined(STM32F37X)
;;;305      /* Enable the USB interrupt */
;;;306      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;307      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;308      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;309      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;310      NVIC_Init(&NVIC_InitStructure);
;;;311      
;;;312      /* Enable the USB Wake-up interrupt */
;;;313      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;314      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;315      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;316      NVIC_Init(&NVIC_InitStructure);
;;;317      
;;;318    #else 
;;;319      /* Enable the USB interrupt */
;;;320      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
;;;321      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;322      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;323      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;324      NVIC_Init(&NVIC_InitStructure);
;;;325      
;;;326        /* Enable the USB Wake-up interrupt */
;;;327      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;328      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;329      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;330      NVIC_Init(&NVIC_InitStructure);
;;;331      
;;;332    #endif /* STM32L1XX_XD */
;;;333    }
00003c  bd38              POP      {r3-r5,pc}
;;;334    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 144
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
