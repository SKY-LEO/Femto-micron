; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_rtc.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_rtc.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_rtc.crf ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1248     */
;;;1249   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1250   {
;;;1251     __IO uint32_t alarmcounter = 0x00;
000002  2200              MOVS     r2,#0
;;;1252     uint32_t alarmstatus = 0x00;
;;;1253     ErrorStatus status = ERROR;
;;;1254       
;;;1255     /* Check the parameters */
;;;1256     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1257     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1258   
;;;1259     /* Disable the write protection for RTC registers */
;;;1260     RTC->WPR = 0xCA;
000004  4b12              LDR      r3,|L1.80|
000006  9200              STR      r2,[sp,#0]
000008  22ca              MOVS     r2,#0xca
00000a  601a              STR      r2,[r3,#0]
;;;1261     RTC->WPR = 0x53;
00000c  2253              MOVS     r2,#0x53
00000e  601a              STR      r2,[r3,#0]
;;;1262   
;;;1263     /* Configure the Alarm state */
;;;1264     if (NewState != DISABLE)
;;;1265     {
;;;1266       RTC->CR |= (uint32_t)RTC_Alarm;
000010  4a0f              LDR      r2,|L1.80|
000012  3a1c              SUBS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;1264
;;;1267   
;;;1268       status = SUCCESS;    
;;;1269     }
;;;1270     else
;;;1271     { 
;;;1272       /* Disable the Alarm in RTC_CR register */
;;;1273       RTC->CR &= (uint32_t)~RTC_Alarm;
000016  6811              LDR      r1,[r2,#0]
000018  d002              BEQ      |L1.32|
00001a  4301              ORRS     r1,r1,r0              ;1266
00001c  6011              STR      r1,[r2,#0]            ;1266
00001e  e012              B        |L1.70|
                  |L1.32|
000020  4381              BICS     r1,r1,r0
000022  6011              STR      r1,[r2,#0]
;;;1274      
;;;1275       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1276       do
;;;1277       {
;;;1278         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000024  4a0a              LDR      r2,|L1.80|
000026  3a18              SUBS     r2,r2,#0x18
;;;1279         alarmcounter++;  
;;;1280       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000028  1455              ASRS     r5,r2,#17
                  |L1.42|
00002a  6811              LDR      r1,[r2,#0]            ;1278
00002c  9c00              LDR      r4,[sp,#0]            ;1279
00002e  ea012110          AND      r1,r1,r0,LSR #8       ;1278
000032  1c64              ADDS     r4,r4,#1              ;1279
000034  9400              STR      r4,[sp,#0]
000036  42ac              CMP      r4,r5
000038  d001              BEQ      |L1.62|
00003a  2900              CMP      r1,#0
00003c  d0f5              BEQ      |L1.42|
                  |L1.62|
;;;1281       
;;;1282       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
00003e  6811              LDR      r1,[r2,#0]
000040  ea112010          ANDS     r0,r1,r0,LSR #8
000044  d000              BEQ      |L1.72|
                  |L1.70|
;;;1283       {
;;;1284         status = ERROR;
;;;1285       } 
;;;1286       else
;;;1287       {
;;;1288         status = SUCCESS;
000046  2001              MOVS     r0,#1
                  |L1.72|
;;;1289       }        
;;;1290     } 
;;;1291   
;;;1292     /* Enable the write protection for RTC registers */
;;;1293     RTC->WPR = 0xFF;
000048  21ff              MOVS     r1,#0xff
00004a  6019              STR      r1,[r3,#0]
;;;1294     
;;;1295     return status;
;;;1296   }
00004c  bd38              POP      {r3-r5,pc}
;;;1297   
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1164     */
;;;1165   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1166   {
;;;1167     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1168     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1169     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1170     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1171     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1172   
;;;1173     /* Alarm Date Settings : Date = 1st day of the month */
;;;1174     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1175     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000a  2201              MOVS     r2,#1
00000c  6081              STR      r1,[r0,#8]
00000e  7302              STRB     r2,[r0,#0xc]
;;;1176   
;;;1177     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1178     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  6041              STR      r1,[r0,#4]
;;;1179   }
000012  4770              BX       lr
;;;1180   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1342     */
;;;1343   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  b510              PUSH     {r4,lr}
;;;1344   {
;;;1345     uint32_t tmpreg = 0;
;;;1346   
;;;1347     /* Check the parameters */
;;;1348     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1349     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1350     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1351     
;;;1352     /* Disable the write protection for RTC registers */
;;;1353     RTC->WPR = 0xCA;
000002  4b09              LDR      r3,|L3.40|
000004  24ca              MOVS     r4,#0xca
000006  601c              STR      r4,[r3,#0]
;;;1354     RTC->WPR = 0x53;
000008  2453              MOVS     r4,#0x53
00000a  601c              STR      r4,[r3,#0]
;;;1355     
;;;1356     /* Configure the Alarm A or Alarm B SubSecond registers */
;;;1357     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
00000c  4311              ORRS     r1,r1,r2
;;;1358     
;;;1359     if (RTC_Alarm == RTC_Alarm_A)
00000e  f5b07f80          CMP      r0,#0x100
000012  d005              BEQ      |L3.32|
;;;1360     {
;;;1361       /* Configure the AlarmA SubSecond register */
;;;1362       RTC->ALRMASSR = tmpreg;
;;;1363     }
;;;1364     else
;;;1365     {
;;;1366       /* Configure the Alarm B SubSecond register */
;;;1367       RTC->ALRMBSSR = tmpreg;
000014  4804              LDR      r0,|L3.40|
000016  3024              ADDS     r0,r0,#0x24
                  |L3.24|
000018  6001              STR      r1,[r0,#0]
;;;1368     }
;;;1369   
;;;1370     /* Enable the write protection for RTC registers */
;;;1371     RTC->WPR = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  6018              STR      r0,[r3,#0]
;;;1372   
;;;1373   }
00001e  bd10              POP      {r4,pc}
                  |L3.32|
000020  4801              LDR      r0,|L3.40|
000022  3020              ADDS     r0,r0,#0x20           ;1362
000024  e7f8              B        |L3.24|
;;;1374   
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40002824

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2655     */
;;;2656   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;2657   {
;;;2658     uint8_t tmp = 0;
;;;2659     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000002  eb010181          ADD      r1,r1,r1,LSL #2
;;;2660     return (tmp + (Value & (uint8_t)0x0F));
000006  f000000f          AND      r0,r0,#0xf
00000a  eb000041          ADD      r0,r0,r1,LSL #1
00000e  b2c0              UXTB     r0,r0
;;;2661   }
000010  4770              BX       lr
;;;2662   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;648    */
;;;649    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L5.40|
;;;650    {
;;;651      /* Check the parameters */
;;;652      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;653    
;;;654      /* Disable the write protection for RTC registers */
;;;655      RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;656      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;657      
;;;658      if (NewState != DISABLE)
;;;659      {
;;;660        /* Set the BYPSHAD bit */
;;;661        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000a  4907              LDR      r1,|L5.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;658
;;;662      }
;;;663      else
;;;664      {
;;;665        /* Reset the BYPSHAD bit */
;;;666        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L5.26|
000014  f0400020          ORR      r0,r0,#0x20           ;661
000018  e001              B        |L5.30|
                  |L5.26|
00001a  f00000df          AND      r0,r0,#0xdf
                  |L5.30|
00001e  6008              STR      r0,[r1,#0]
;;;667      }
;;;668    
;;;669      /* Enable the write protection for RTC registers */
;;;670      RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;671    }
000024  4770              BX       lr
;;;672    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40002824

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2637     */
;;;2638   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2639   {
000002  e003              B        |L6.12|
                  |L6.4|
000004  1c49              ADDS     r1,r1,#1
;;;2640     uint8_t bcdhigh = 0;
;;;2641     
;;;2642     while (Value >= 10)
;;;2643     {
;;;2644       bcdhigh++;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c9              UXTB     r1,r1
;;;2645       Value -= 10;
00000a  b2c0              UXTB     r0,r0
                  |L6.12|
00000c  280a              CMP      r0,#0xa               ;2642
00000e  d2f9              BCS      |L6.4|
;;;2646     }
;;;2647     
;;;2648     return  ((uint8_t)(bcdhigh << 4) | Value);
000010  0709              LSLS     r1,r1,#28
000012  ea406011          ORR      r0,r0,r1,LSR #24
;;;2649   }
000016  4770              BX       lr
;;;2650   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1771     */
;;;1772   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L7.40|
;;;1773   {
;;;1774     /* Check the parameters */
;;;1775     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1776     
;;;1777     /* Disable the write protection for RTC registers */
;;;1778     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1779     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1780     
;;;1781     if (NewState != DISABLE)
;;;1782     {
;;;1783       /* Enable the RTC clock output */
;;;1784       RTC->CR |= (uint32_t)RTC_CR_COE;
00000a  4907              LDR      r1,|L7.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;1781
;;;1785     }
;;;1786     else
;;;1787     { 
;;;1788       /* Disable the RTC clock output */
;;;1789       RTC->CR &= (uint32_t)~RTC_CR_COE;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L7.26|
000014  f4400000          ORR      r0,r0,#0x800000       ;1784
000018  e001              B        |L7.30|
                  |L7.26|
00001a  f4200000          BIC      r0,r0,#0x800000
                  |L7.30|
00001e  6008              STR      r0,[r1,#0]
;;;1790     }
;;;1791     
;;;1792     /* Enable the write protection for RTC registers */
;;;1793     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;1794   }
000024  4770              BX       lr
;;;1795   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40002824

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1803   */
;;;1804   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  4a08              LDR      r2,|L8.36|
;;;1805   {
;;;1806     /* Check the parameters */
;;;1807     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1808   
;;;1809     /* Disable the write protection for RTC registers */
;;;1810     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1811     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1812     
;;;1813     /*clear flags before config*/
;;;1814     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
00000a  4906              LDR      r1,|L8.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f4232300          BIC      r3,r3,#0x80000
000014  600b              STR      r3,[r1,#0]
;;;1815   
;;;1816     /* Configure the RTC_CR register */
;;;1817     RTC->CR |= (uint32_t)RTC_CalibOutput;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1818   
;;;1819     /* Enable the write protection for RTC registers */
;;;1820     RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1821   }
000020  4770              BX       lr
;;;1822   
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2550     */
;;;2551   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  f3c00010          UBFX     r0,r0,#0,#17
;;;2552   {
;;;2553     /* Check the parameters */
;;;2554     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2555   
;;;2556     /* Clear the Flags in the RTC_ISR register */
;;;2557     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));    
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L9.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2558   }
000016  4770              BX       lr
;;;2559   
                          ENDP

                  |L9.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2614     */
;;;2615   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  f3c0100f          UBFX     r0,r0,#4,#16
;;;2616   {
;;;2617     uint32_t tmpreg = 0;
;;;2618   
;;;2619     /* Check the parameters */
;;;2620     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2621   
;;;2622     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2623     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2624   
;;;2625     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2626     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L10.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2627   }
000016  4770              BX       lr
;;;2628   
                          ENDP

                  |L10.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1724     */
;;;1725   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1726   {
;;;1727     ErrorStatus status = ERROR;
;;;1728     
;;;1729     /* Check the parameters */
;;;1730     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1731   
;;;1732     /* Disable the write protection for RTC registers */
;;;1733     RTC->WPR = 0xCA;
000002  4c0d              LDR      r4,|L11.56|
000004  4606              MOV      r6,r0                 ;1726
000006  2500              MOVS     r5,#0                 ;1727
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;1734     RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;1735     
;;;1736     /* Set Initialization mode */
;;;1737     if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L11.48|
;;;1738     {
;;;1739       status =  ERROR;
;;;1740     }
;;;1741     else
;;;1742     {
;;;1743       if (NewState != DISABLE)
;;;1744       {
;;;1745         /* Enable the Coarse Calibration */
;;;1746         RTC->CR |= (uint32_t)RTC_CR_DCE;
000016  4808              LDR      r0,|L11.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;1747       }
;;;1748       else
;;;1749       { 
;;;1750         /* Disable the Coarse Calibration */
;;;1751         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L11.36|
00001e  f0410180          ORR      r1,r1,#0x80           ;1746
000022  e001              B        |L11.40|
                  |L11.36|
000024  f0210180          BIC      r1,r1,#0x80
                  |L11.40|
000028  6001              STR      r1,[r0,#0]
;;;1752       }
;;;1753       /* Exit Initialization mode */
;;;1754       RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;1755       
;;;1756       status = SUCCESS;
00002e  2501              MOVS     r5,#1
                  |L11.48|
;;;1757     } 
;;;1758     
;;;1759     /* Enable the write protection for RTC registers */
;;;1760     RTC->WPR = 0xFF; 
000030  20ff              MOVS     r0,#0xff
000032  6020              STR      r0,[r4,#0]
;;;1761     
;;;1762     return status;
000034  4628              MOV      r0,r5
;;;1763   }
000036  bd70              POP      {r4-r6,pc}
;;;1764   
                          ENDP

                  |L11.56|
                          DCD      0x40002824

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1683     */
;;;1684   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1685   {
;;;1686     ErrorStatus status = ERROR;
;;;1687      
;;;1688     /* Check the parameters */
;;;1689     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1690     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1691   
;;;1692     /* Disable the write protection for RTC registers */
;;;1693     RTC->WPR = 0xCA;
000002  4c0b              LDR      r4,|L12.48|
000004  4606              MOV      r6,r0                 ;1685
000006  2500              MOVS     r5,#0                 ;1686
000008  20ca              MOVS     r0,#0xca
00000a  460f              MOV      r7,r1                 ;1685
00000c  6020              STR      r0,[r4,#0]
;;;1694     RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6020              STR      r0,[r4,#0]
;;;1695   
;;;1696     /* Set Initialization mode */
;;;1697     if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b130              CBZ      r0,|L12.38|
;;;1698     {
;;;1699       status = ERROR;
;;;1700     } 
;;;1701     else
;;;1702     {
;;;1703       /* Set the coarse calibration value */
;;;1704       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
000018  4805              LDR      r0,|L12.48|
00001a  433e              ORRS     r6,r6,r7
00001c  380c              SUBS     r0,r0,#0xc
00001e  6006              STR      r6,[r0,#0]
;;;1705       /* Exit Initialization mode */
;;;1706       RTC_ExitInitMode();
000020  f7fffffe          BL       RTC_ExitInitMode
;;;1707       
;;;1708       status = SUCCESS;
000024  2501              MOVS     r5,#1
                  |L12.38|
;;;1709     } 
;;;1710   
;;;1711     /* Enable the write protection for RTC registers */
;;;1712     RTC->WPR = 0xFF; 
000026  20ff              MOVS     r0,#0xff
000028  6020              STR      r0,[r4,#0]
;;;1713     
;;;1714     return status;
00002a  4628              MOV      r0,r5
;;;1715   }
00002c  bdf0              POP      {r4-r7,pc}
;;;1716   
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40002824

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;974      */
;;;975    void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;976    {
;;;977      /* Monday, January 01 xx00 */
;;;978      RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;979      RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;980      RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;981      RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;982    }
00000c  4770              BX       lr
;;;983    
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1567     */
;;;1568   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  4b09              LDR      r3,|L14.40|
;;;1569   {
000002  b510              PUSH     {r4,lr}
;;;1570     /* Check the parameters */
;;;1571     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1572     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1573   
;;;1574     /* Disable the write protection for RTC registers */
;;;1575     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1576     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1577   
;;;1578     /* Clear the bits to be configured */
;;;1579     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000c  4a06              LDR      r2,|L14.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f4242480          BIC      r4,r4,#0x40000
000016  6014              STR      r4,[r2,#0]
;;;1580   
;;;1581     /* Configure the RTC_CR register */
;;;1582     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1583   
;;;1584     /* Enable the write protection for RTC registers */
;;;1585     RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1586   }
000024  bd10              POP      {r4,pc}
;;;1587   
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;311      */
;;;312    ErrorStatus RTC_DeInit(void)
000000  b578              PUSH     {r3-r6,lr}
;;;313    {
;;;314      __IO uint32_t wutcounter = 0x00;
000002  2400              MOVS     r4,#0
;;;315      uint32_t wutwfstatus = 0x00;
;;;316      ErrorStatus status = ERROR;
;;;317      
;;;318      /* Disable the write protection for RTC registers */
;;;319      RTC->WPR = 0xCA;
000004  4e28              LDR      r6,|L15.168|
000006  20ca              MOVS     r0,#0xca
000008  9400              STR      r4,[sp,#0]
00000a  4625              MOV      r5,r4                 ;316
00000c  6030              STR      r0,[r6,#0]
;;;320      RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6030              STR      r0,[r6,#0]
;;;321    
;;;322      /* Set Initialization mode */
;;;323      if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b3e0              CBZ      r0,|L15.146|
;;;324      {
;;;325        status = ERROR;
;;;326      }  
;;;327      else
;;;328      {
;;;329        /* Reset TR, DR and CR registers */
;;;330        RTC->TR = (uint32_t)0x00000000;
000018  4823              LDR      r0,|L15.168|
00001a  3824              SUBS     r0,r0,#0x24
00001c  6004              STR      r4,[r0,#0]
;;;331        RTC->DR = (uint32_t)0x00002101;
00001e  4922              LDR      r1,|L15.168|
000020  f2421001          MOV      r0,#0x2101
000024  3920              SUBS     r1,r1,#0x20
000026  6008              STR      r0,[r1,#0]
;;;332        
;;;333        /* Reset All CR bits except CR[2:0] */
;;;334        RTC->CR &= (uint32_t)0x00000007;
000028  1d09              ADDS     r1,r1,#4
00002a  6808              LDR      r0,[r1,#0]
00002c  f0000007          AND      r0,r0,#7
000030  6008              STR      r0,[r1,#0]
;;;335      
;;;336        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;337        do
;;;338        {
;;;339          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
;;;340          wutcounter++;  
;;;341        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000032  144d              ASRS     r5,r1,#17
000034  1d08              ADDS     r0,r1,#4              ;339
                  |L15.54|
000036  6802              LDR      r2,[r0,#0]            ;339
000038  9b00              LDR      r3,[sp,#0]            ;340
00003a  f0020204          AND      r2,r2,#4              ;339
00003e  1c5b              ADDS     r3,r3,#1              ;340
000040  9300              STR      r3,[sp,#0]
000042  42ab              CMP      r3,r5
000044  d001              BEQ      |L15.74|
000046  2a00              CMP      r2,#0
000048  d0f5              BEQ      |L15.54|
                  |L15.74|
;;;342        
;;;343        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00004a  6802              LDR      r2,[r0,#0]
00004c  0752              LSLS     r2,r2,#29
00004e  d529              BPL      |L15.164|
;;;344        {
;;;345          status = ERROR;
;;;346        }
;;;347        else
;;;348        {
;;;349          /* Reset all RTC CR register bits */
;;;350          RTC->CR        &= (uint32_t)0x00000000;
000050  680a              LDR      r2,[r1,#0]
000052  600c              STR      r4,[r1,#0]
;;;351          RTC->WUTR      = (uint32_t)0x0000FFFF;
000054  4a14              LDR      r2,|L15.168|
000056  f64f71ff          MOV      r1,#0xffff
00005a  3a10              SUBS     r2,r2,#0x10
00005c  6011              STR      r1,[r2,#0]
;;;352          RTC->PRER      = (uint32_t)0x007F00FF;
00005e  1f12              SUBS     r2,r2,#4
000060  4912              LDR      r1,|L15.172|
000062  6011              STR      r1,[r2,#0]
;;;353          RTC->CALIBR    = (uint32_t)0x00000000;
000064  4910              LDR      r1,|L15.168|
000066  390c              SUBS     r1,r1,#0xc
000068  600c              STR      r4,[r1,#0]
;;;354          RTC->ALRMAR    = (uint32_t)0x00000000;
00006a  1d09              ADDS     r1,r1,#4
00006c  600c              STR      r4,[r1,#0]
;;;355          RTC->ALRMBR    = (uint32_t)0x00000000;
00006e  1d09              ADDS     r1,r1,#4
000070  600c              STR      r4,[r1,#0]
;;;356          RTC->SHIFTR    = (uint32_t)0x00000000;
000072  490d              LDR      r1,|L15.168|
000074  3108              ADDS     r1,r1,#8
000076  600c              STR      r4,[r1,#0]
;;;357          RTC->CALR       = (uint32_t)0x00000000;
000078  490b              LDR      r1,|L15.168|
00007a  3118              ADDS     r1,r1,#0x18
00007c  600c              STR      r4,[r1,#0]
;;;358          RTC->ALRMASSR  = (uint32_t)0x00000000;
00007e  490a              LDR      r1,|L15.168|
000080  3120              ADDS     r1,r1,#0x20
000082  600c              STR      r4,[r1,#0]
;;;359          RTC->ALRMBSSR  = (uint32_t)0x00000000;
000084  1d09              ADDS     r1,r1,#4
000086  600c              STR      r4,[r1,#0]
;;;360    
;;;361          /* Reset ISR register and exit initialization mode */
;;;362          RTC->ISR = (uint32_t)0x00000000;
000088  6004              STR      r4,[r0,#0]
;;;363          
;;;364          /* Reset Tamper and alternate functions configuration register */
;;;365          RTC->TAFCR = 0x00000000;
00008a  4807              LDR      r0,|L15.168|
00008c  301c              ADDS     r0,r0,#0x1c
00008e  6004              STR      r4,[r0,#0]
;;;366          
;;;367          /* Wait till the RTC RSF flag is set */
;;;368          if (RTC_WaitForSynchro() == ERROR)
000090  e000              B        |L15.148|
                  |L15.146|
000092  e003              B        |L15.156|
                  |L15.148|
000094  f7fffffe          BL       RTC_WaitForSynchro
000098  b120              CBZ      r0,|L15.164|
;;;369          {
;;;370            status = ERROR;
;;;371          }
;;;372          else
;;;373          {
;;;374            status = SUCCESS;
00009a  2501              MOVS     r5,#1
                  |L15.156|
;;;375          }
;;;376        }
;;;377      }
;;;378      
;;;379      /* Enable the write protection for RTC registers */
;;;380      RTC->WPR = 0xFF;  
00009c  20ff              MOVS     r0,#0xff
00009e  6030              STR      r0,[r6,#0]
;;;381      
;;;382      return status;
0000a0  4628              MOV      r0,r5
;;;383    }
0000a2  bd78              POP      {r3-r6,pc}
                  |L15.164|
0000a4  2500              MOVS     r5,#0                 ;370
0000a6  e7f9              B        |L15.156|
;;;384    
                          ENDP

                  |L15.168|
                          DCD      0x40002824
                  |L15.172|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;490      */
;;;491    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;492    {
;;;493      __IO uint32_t initcounter = 0x00;
000002  2000              MOVS     r0,#0
;;;494      ErrorStatus status = ERROR;
;;;495      uint32_t initstatus = 0x00;
;;;496         
;;;497      /* Check if the Initialization mode is set */
;;;498      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000004  9000              STR      r0,[sp,#0]
000006  480c              LDR      r0,|L16.56|
000008  6801              LDR      r1,[r0,#0]
00000a  0649              LSLS     r1,r1,#25
00000c  d412              BMI      |L16.52|
;;;499      {
;;;500        /* Set the Initialization mode */
;;;501        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00000e  f04f31ff          MOV      r1,#0xffffffff
000012  6001              STR      r1,[r0,#0]
;;;502        
;;;503        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;504        do
;;;505        {
;;;506          initstatus = RTC->ISR & RTC_ISR_INITF;
;;;507          initcounter++;  
;;;508        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000014  1443              ASRS     r3,r0,#17
                  |L16.22|
000016  6801              LDR      r1,[r0,#0]            ;506
000018  9a00              LDR      r2,[sp,#0]            ;507
00001a  f0010140          AND      r1,r1,#0x40           ;506
00001e  1c52              ADDS     r2,r2,#1              ;507
000020  9200              STR      r2,[sp,#0]
000022  429a              CMP      r2,r3
000024  d001              BEQ      |L16.42|
000026  2900              CMP      r1,#0
000028  d0f5              BEQ      |L16.22|
                  |L16.42|
;;;509        
;;;510        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00002a  6800              LDR      r0,[r0,#0]
00002c  0640              LSLS     r0,r0,#25
00002e  d401              BMI      |L16.52|
;;;511        {
;;;512          status = SUCCESS;
;;;513        }
;;;514        else
;;;515        {
;;;516          status = ERROR;
000030  2000              MOVS     r0,#0
;;;517        }        
;;;518      }
;;;519      else
;;;520      {
;;;521        status = SUCCESS;  
;;;522      } 
;;;523        
;;;524      return (status);  
;;;525    }
000032  bd08              POP      {r3,pc}
                  |L16.52|
000034  2001              MOVS     r0,#1                 ;521
000036  bd08              POP      {r3,pc}
;;;526    
                          ENDP

                  |L16.56|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;535      */
;;;536    void RTC_ExitInitMode(void)
000000  4802              LDR      r0,|L17.12|
;;;537    {
;;;538      /* Exit Initialization mode */
;;;539      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;540    }
00000a  4770              BX       lr
;;;541    
                          ENDP

                  |L17.12|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1194     */
;;;1195   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b510              PUSH     {r4,lr}
;;;1196   {
000002  4614              MOV      r4,r2
;;;1197     uint32_t tmpreg = 0;
;;;1198   
;;;1199     /* Check the parameters */
;;;1200     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1201     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1202   
;;;1203     /* Get the RTC_ALRMxR register */
;;;1204     if (RTC_Alarm == RTC_Alarm_A)
000004  f5b17f80          CMP      r1,#0x100
000008  d02a              BEQ      |L18.96|
;;;1205     {
;;;1206       tmpreg = (uint32_t)(RTC->ALRMAR);
;;;1207     }
;;;1208     else
;;;1209     {
;;;1210       tmpreg = (uint32_t)(RTC->ALRMBR);
00000a  4917              LDR      r1,|L18.104|
                  |L18.12|
00000c  6809              LDR      r1,[r1,#0]
;;;1211     }
;;;1212   
;;;1213     /* Fill the structure with the read parameters */
;;;1214     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00000e  f3c14205          UBFX     r2,r1,#16,#6
000012  7022              STRB     r2,[r4,#0]
;;;1215                                                        RTC_ALRMAR_HU)) >> 16);
;;;1216     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000014  f3c12306          UBFX     r3,r1,#8,#7
000018  7063              STRB     r3,[r4,#1]
;;;1217                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1218     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00001a  f001037f          AND      r3,r1,#0x7f
00001e  70a3              STRB     r3,[r4,#2]
;;;1219                                                        RTC_ALRMAR_SU));
;;;1220     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000020  2340              MOVS     r3,#0x40
000022  ea034311          AND      r3,r3,r1,LSR #16
000026  70e3              STRB     r3,[r4,#3]
;;;1221     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000028  f3c16305          UBFX     r3,r1,#24,#6
00002c  7323              STRB     r3,[r4,#0xc]
;;;1222     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00002e  f0014380          AND      r3,r1,#0x40000000
;;;1223     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000032  f0013180          AND      r1,r1,#0x80808080
000036  e9c41301          STRD     r1,r3,[r4,#4]
00003a  2800              CMP      r0,#0
00003c  d10f              BNE      |L18.94|
00003e  4610              MOV      r0,r2
;;;1224   
;;;1225     if (RTC_Format == RTC_Format_BIN)
;;;1226     {
;;;1227       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  7020              STRB     r0,[r4,#0]
;;;1228                                                           RTC_AlarmTime.RTC_Hours);
;;;1229       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000046  7860              LDRB     r0,[r4,#1]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  7060              STRB     r0,[r4,#1]
;;;1230                                                           RTC_AlarmTime.RTC_Minutes);
;;;1231       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004e  78a0              LDRB     r0,[r4,#2]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  70a0              STRB     r0,[r4,#2]
;;;1232                                                           RTC_AlarmTime.RTC_Seconds);
;;;1233       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000056  7b20              LDRB     r0,[r4,#0xc]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7320              STRB     r0,[r4,#0xc]
                  |L18.94|
;;;1234     }  
;;;1235   }
00005e  bd10              POP      {r4,pc}
                  |L18.96|
000060  4901              LDR      r1,|L18.104|
000062  1f09              SUBS     r1,r1,#4              ;1206
000064  e7d2              B        |L18.12|
;;;1236   
                          ENDP

000066  0000              DCW      0x0000
                  |L18.104|
                          DCD      0x40002820

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1383     */
;;;1384   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  f5b07f80          CMP      r0,#0x100
;;;1385   {
000004  d004              BEQ      |L19.16|
;;;1386     uint32_t tmpreg = 0;
;;;1387     
;;;1388     /* Get the RTC_ALRMxR register */
;;;1389     if (RTC_Alarm == RTC_Alarm_A)
;;;1390     {
;;;1391       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000006  4804              LDR      r0,|L19.24|
                  |L19.8|
000008  6800              LDR      r0,[r0,#0]            ;1391
00000a  f3c0000e          UBFX     r0,r0,#0,#15          ;1391
;;;1396     } 
;;;1397     
;;;1398     return (tmpreg);
;;;1399   }
00000e  4770              BX       lr
                  |L19.16|
000010  4801              LDR      r0,|L19.24|
000012  1f00              SUBS     r0,r0,#4              ;1391
000014  e7f8              B        |L19.8|
;;;1400   
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40002848

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;993      */
;;;994    void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b510              PUSH     {r4,lr}
;;;995    {
000002  460c              MOV      r4,r1
;;;996      uint32_t tmpreg = 0;
;;;997    
;;;998      /* Check the parameters */
;;;999      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1000     
;;;1001     /* Get the RTC_TR register */
;;;1002     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000004  490e              LDR      r1,|L20.64|
000006  6809              LDR      r1,[r1,#0]
000008  4a0e              LDR      r2,|L20.68|
00000a  4011              ANDS     r1,r1,r2
;;;1003   
;;;1004     /* Fill the structure fields with the read parameters */
;;;1005     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
00000c  0c0a              LSRS     r2,r1,#16
00000e  70e2              STRB     r2,[r4,#3]
;;;1006     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000010  f3c12304          UBFX     r3,r1,#8,#5
000014  7063              STRB     r3,[r4,#1]
;;;1007     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
000016  f001033f          AND      r3,r1,#0x3f
00001a  70a3              STRB     r3,[r4,#2]
;;;1008     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
00001c  f3c13142          UBFX     r1,r1,#13,#3
000020  7021              STRB     r1,[r4,#0]
000022  2800              CMP      r0,#0                 ;995
000024  d10b              BNE      |L20.62|
000026  4610              MOV      r0,r2                 ;995
;;;1009   
;;;1010     /* Check the input parameters format */
;;;1011     if (RTC_Format == RTC_Format_BIN)
;;;1012     {
;;;1013       /* Convert the structure parameters to Binary format */
;;;1014       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
000028  f7fffffe          BL       RTC_Bcd2ToByte
00002c  70e0              STRB     r0,[r4,#3]
;;;1015       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_Bcd2ToByte
000034  7060              STRB     r0,[r4,#1]
;;;1016       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);   
000036  78a0              LDRB     r0,[r4,#2]
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  70a0              STRB     r0,[r4,#2]
                  |L20.62|
;;;1017     }
;;;1018   }
00003e  bd10              POP      {r4,pc}
;;;1019   
                          ENDP

                  |L20.64|
                          DCD      0x40002804
                  |L20.68|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2512     */
;;;2513   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  4904              LDR      r1,|L21.20|
;;;2514   {
000002  4602              MOV      r2,r0
;;;2515     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2516     uint32_t tmpreg = 0;
;;;2517     
;;;2518     /* Check the parameters */
;;;2519     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2520     
;;;2521     /* Get all the flags */
;;;2522     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000006  6809              LDR      r1,[r1,#0]
000008  4b03              LDR      r3,|L21.24|
00000a  4019              ANDS     r1,r1,r3
;;;2523     
;;;2524     /* Return the status of the flag */
;;;2525     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00000c  4211              TST      r1,r2
00000e  d000              BEQ      |L21.18|
;;;2526     {
;;;2527       bitstatus = SET;
000010  2001              MOVS     r0,#1
                  |L21.18|
;;;2528     }
;;;2529     else
;;;2530     {
;;;2531       bitstatus = RESET;
;;;2532     }
;;;2533     return bitstatus;
;;;2534   }
000012  4770              BX       lr
;;;2535   
                          ENDP

                  |L21.20|
                          DCD      0x4000280c
                  |L21.24|
                          DCD      0x0001ff7f

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2572     */
;;;2573   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  4a0d              LDR      r2,|L22.56|
;;;2574   {
000002  b510              PUSH     {r4,lr}
;;;2575     ITStatus bitstatus = RESET;
;;;2576     uint32_t tmpreg = 0, enablestatus = 0;
;;;2577    
;;;2578     /* Check the parameters */
;;;2579     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2580     
;;;2581     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2582     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
000004  6812              LDR      r2,[r2,#0]
000006  2100              MOVS     r1,#0                 ;2575
000008  f0020304          AND      r3,r2,#4
;;;2583    
;;;2584     /* Get the Interrupt enable Status */
;;;2585     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
00000c  4a0a              LDR      r2,|L22.56|
00000e  3a38              SUBS     r2,r2,#0x38
000010  6812              LDR      r2,[r2,#0]
000012  0c84              LSRS     r4,r0,#18
000014  fa20f404          LSR      r4,r0,r4
000018  4002              ANDS     r2,r2,r0
00001a  ea0333d4          AND      r3,r3,r4,LSR #15
00001e  431a              ORRS     r2,r2,r3
;;;2586     
;;;2587     /* Get the Interrupt pending bit */
;;;2588     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000020  4b06              LDR      r3,|L22.60|
000022  681b              LDR      r3,[r3,#0]
000024  ea031010          AND      r0,r3,r0,LSR #4
000028  d003              BEQ      |L22.50|
;;;2589     
;;;2590     /* Get the status of the Interrupt */
;;;2591     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
00002a  0400              LSLS     r0,r0,#16
00002c  0c00              LSRS     r0,r0,#16
00002e  d000              BEQ      |L22.50|
;;;2592     {
;;;2593       bitstatus = SET;
000030  2101              MOVS     r1,#1
                  |L22.50|
;;;2594     }
;;;2595     else
;;;2596     {
;;;2597       bitstatus = RESET;
;;;2598     }
;;;2599     return bitstatus;
000032  4608              MOV      r0,r1
;;;2600   }
000034  bd10              POP      {r4,pc}
;;;2601   
                          ENDP

000036  0000              DCW      0x0000
                  |L22.56|
                          DCD      0x40002840
                  |L22.60|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1594     */
;;;1595   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L23.12|
;;;1596   {
;;;1597     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1598   }
000008  4770              BX       lr
;;;1599   
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;858      */
;;;859    uint32_t RTC_GetSubSecond(void)
000000  4802              LDR      r0,|L24.12|
;;;860    {
;;;861      uint32_t tmpreg = 0;
;;;862      
;;;863      /* Get subseconds values from the correspondent registers*/
;;;864      tmpreg = (uint32_t)(RTC->SSR);
000002  6800              LDR      r0,[r0,#0]
;;;865      
;;;866      /* Read DR register to unfroze calendar registers */
;;;867      (void) (RTC->DR);
000004  4901              LDR      r1,|L24.12|
000006  3924              SUBS     r1,r1,#0x24
000008  6809              LDR      r1,[r1,#0]
;;;868      
;;;869      return (tmpreg);
;;;870    }
00000a  4770              BX       lr
;;;871    
                          ENDP

                  |L24.12|
                          DCD      0x40002828

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;825      */
;;;826    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b510              PUSH     {r4,lr}
;;;827    {
000002  460c              MOV      r4,r1
;;;828      uint32_t tmpreg = 0;
;;;829    
;;;830      /* Check the parameters */
;;;831      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;832    
;;;833      /* Get the RTC_TR register */
;;;834      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000004  490f              LDR      r1,|L25.68|
000006  6809              LDR      r1,[r1,#0]
000008  4a0f              LDR      r2,|L25.72|
00000a  4011              ANDS     r1,r1,r2
;;;835      
;;;836      /* Fill the structure fields with the read parameters */
;;;837      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00000c  f3c14205          UBFX     r2,r1,#16,#6
000010  7022              STRB     r2,[r4,#0]
;;;838      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000012  f3c12306          UBFX     r3,r1,#8,#7
000016  7063              STRB     r3,[r4,#1]
;;;839      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000018  f001037f          AND      r3,r1,#0x7f
00001c  70a3              STRB     r3,[r4,#2]
;;;840      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
00001e  2340              MOVS     r3,#0x40
000020  ea034111          AND      r1,r3,r1,LSR #16
000024  70e1              STRB     r1,[r4,#3]
000026  2800              CMP      r0,#0                 ;827
000028  d10b              BNE      |L25.66|
00002a  4610              MOV      r0,r2                 ;827
;;;841    
;;;842      /* Check the input parameters format */
;;;843      if (RTC_Format == RTC_Format_BIN)
;;;844      {
;;;845        /* Convert the structure parameters to Binary format */
;;;846        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002c  f7fffffe          BL       RTC_Bcd2ToByte
000030  7020              STRB     r0,[r4,#0]
;;;847        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000032  7860              LDRB     r0,[r4,#1]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  7060              STRB     r0,[r4,#1]
;;;848        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  70a0              STRB     r0,[r4,#2]
                  |L25.66|
;;;849      }
;;;850    }
000042  bd10              POP      {r4,pc}
;;;851    
                          ENDP

                  |L25.68|
                          DCD      0x40002800
                  |L25.72|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;1959     */
;;;1960   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  b570              PUSH     {r4-r6,lr}
;;;1961                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;1962   {
000002  460d              MOV      r5,r1
;;;1963     uint32_t tmptime = 0, tmpdate = 0;
;;;1964   
;;;1965     /* Check the parameters */
;;;1966     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1967   
;;;1968     /* Get the TimeStamp time and date registers values */
;;;1969     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000004  491e              LDR      r1,|L26.128|
000006  4614              MOV      r4,r2                 ;1962
000008  6809              LDR      r1,[r1,#0]
00000a  4a1e              LDR      r2,|L26.132|
00000c  4011              ANDS     r1,r1,r2
;;;1970     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
00000e  4a1c              LDR      r2,|L26.128|
000010  1d12              ADDS     r2,r2,#4
000012  6812              LDR      r2,[r2,#0]
000014  f64f733f          MOV      r3,#0xff3f
000018  401a              ANDS     r2,r2,r3
;;;1971   
;;;1972     /* Fill the Time structure fields with the read parameters */
;;;1973     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00001a  f3c14305          UBFX     r3,r1,#16,#6
00001e  702b              STRB     r3,[r5,#0]
;;;1974     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000020  f3c12306          UBFX     r3,r1,#8,#7
000024  706b              STRB     r3,[r5,#1]
;;;1975     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000026  f001037f          AND      r3,r1,#0x7f
00002a  70ab              STRB     r3,[r5,#2]
;;;1976     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
00002c  2340              MOVS     r3,#0x40
00002e  ea034111          AND      r1,r3,r1,LSR #16
000032  70e9              STRB     r1,[r5,#3]
;;;1977   
;;;1978     /* Fill the Date structure fields with the read parameters */
;;;1979     RTC_StampDateStruct->RTC_Year = 0;
000034  2100              MOVS     r1,#0
000036  70e1              STRB     r1,[r4,#3]
;;;1980     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000038  f3c22104          UBFX     r1,r2,#8,#5
00003c  7061              STRB     r1,[r4,#1]
;;;1981     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00003e  f002013f          AND      r1,r2,#0x3f
000042  70a1              STRB     r1,[r4,#2]
;;;1982     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000044  f3c23142          UBFX     r1,r2,#13,#3
000048  7021              STRB     r1,[r4,#0]
00004a  2800              CMP      r0,#0                 ;1962
00004c  d117              BNE      |L26.126|
;;;1983   
;;;1984     /* Check the input parameters format */
;;;1985     if (RTC_Format == RTC_Format_BIN)
;;;1986     {
;;;1987       /* Convert the Time structure parameters to Binary format */
;;;1988       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
00004e  7828              LDRB     r0,[r5,#0]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  7028              STRB     r0,[r5,#0]
;;;1989       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000056  7868              LDRB     r0,[r5,#1]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7068              STRB     r0,[r5,#1]
;;;1990       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
00005e  78a8              LDRB     r0,[r5,#2]
000060  f7fffffe          BL       RTC_Bcd2ToByte
000064  70a8              STRB     r0,[r5,#2]
;;;1991   
;;;1992       /* Convert the Date structure parameters to Binary format */
;;;1993       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000066  7860              LDRB     r0,[r4,#1]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7060              STRB     r0,[r4,#1]
;;;1994       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00006e  78a0              LDRB     r0,[r4,#2]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  70a0              STRB     r0,[r4,#2]
;;;1995       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000076  7820              LDRB     r0,[r4,#0]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  7020              STRB     r0,[r4,#0]
                  |L26.126|
;;;1996     }
;;;1997   }
00007e  bd70              POP      {r4-r6,pc}
;;;1998   
                          ENDP

                  |L26.128|
                          DCD      0x40002830
                  |L26.132|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;2003     */
;;;2004   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L27.8|
;;;2005   {
;;;2006     /* Get timestamp subseconds values from the correspondent registers */
;;;2007     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;2008   }
000004  4770              BX       lr
;;;2009   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1479     */
;;;1480   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L28.8|
;;;1481   {
;;;1482     /* Get the counter value */
;;;1483     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1484   }
000006  4770              BX       lr
;;;1485   
                          ENDP

                  |L28.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2462     */
;;;2463   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;2464   {
;;;2465     /* Check the parameters */
;;;2466     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2467     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2468   
;;;2469     /* Disable the write protection for RTC registers */
;;;2470     RTC->WPR = 0xCA;
000002  4d0e              LDR      r5,|L29.60|
000004  22ca              MOVS     r2,#0xca
000006  602a              STR      r2,[r5,#0]
;;;2471     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  602a              STR      r2,[r5,#0]
;;;2472   
;;;2473     if (NewState != DISABLE)
;;;2474     {
;;;2475       /* Configure the Interrupts in the RTC_CR register */
;;;2476       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4b0b              LDR      r3,|L29.60|
;;;2477       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2478       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00000e  4a0b              LDR      r2,|L29.60|
000010  3b1c              SUBS     r3,r3,#0x1c           ;2476
000012  321c              ADDS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;2473
000016  f0200404          BIC      r4,r0,#4              ;2476
;;;2479     }
;;;2480     else
;;;2481     {
;;;2482       /* Configure the Interrupts in the RTC_CR register */
;;;2483       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
00001a  6819              LDR      r1,[r3,#0]
00001c  f0000004          AND      r0,r0,#4              ;2478
000020  d004              BEQ      |L29.44|
000022  4321              ORRS     r1,r1,r4              ;2476
000024  6019              STR      r1,[r3,#0]            ;2476
000026  6811              LDR      r1,[r2,#0]            ;2478
000028  4301              ORRS     r1,r1,r0              ;2478
00002a  e003              B        |L29.52|
                  |L29.44|
00002c  43a1              BICS     r1,r1,r4
00002e  6019              STR      r1,[r3,#0]
;;;2484       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2485       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000030  6811              LDR      r1,[r2,#0]
000032  4381              BICS     r1,r1,r0
                  |L29.52|
000034  6011              STR      r1,[r2,#0]
;;;2486     }
;;;2487     /* Enable the write protection for RTC registers */
;;;2488     RTC->WPR = 0xFF; 
000036  20ff              MOVS     r0,#0xff
000038  6028              STR      r0,[r5,#0]
;;;2489   }
00003a  bd30              POP      {r4,r5,pc}
;;;2490   
                          ENDP

                  |L29.60|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;395      */
;;;396    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;397    {
;;;398      ErrorStatus status = ERROR;
;;;399      
;;;400      /* Check the parameters */
;;;401      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;402      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;403      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;404    
;;;405      /* Disable the write protection for RTC registers */
;;;406      RTC->WPR = 0xCA;
000002  4d12              LDR      r5,|L30.76|
000004  4604              MOV      r4,r0                 ;397
000006  2600              MOVS     r6,#0                 ;398
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;407      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;408    
;;;409      /* Set Initialization mode */
;;;410      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b1a8              CBZ      r0,|L30.66|
;;;411      {
;;;412        status = ERROR;
;;;413      } 
;;;414      else
;;;415      {
;;;416        /* Clear RTC CR FMT Bit */
;;;417        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000016  480d              LDR      r0,|L30.76|
000018  381c              SUBS     r0,r0,#0x1c
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210140          BIC      r1,r1,#0x40
000020  6001              STR      r1,[r0,#0]
;;;418        /* Set RTC_CR register */
;;;419        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000022  6801              LDR      r1,[r0,#0]
000024  6822              LDR      r2,[r4,#0]
000026  4311              ORRS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;420      
;;;421        /* Configure the RTC PRER */
;;;422        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
00002a  4808              LDR      r0,|L30.76|
00002c  68a1              LDR      r1,[r4,#8]
00002e  3814              SUBS     r0,r0,#0x14
000030  6001              STR      r1,[r0,#0]
;;;423        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000032  6801              LDR      r1,[r0,#0]
000034  88a2              LDRH     r2,[r4,#4]
000036  ea414102          ORR      r1,r1,r2,LSL #16
00003a  6001              STR      r1,[r0,#0]
;;;424    
;;;425        /* Exit Initialization mode */
;;;426        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;427    
;;;428        status = SUCCESS;    
000040  2601              MOVS     r6,#1
                  |L30.66|
;;;429      }
;;;430      /* Enable the write protection for RTC registers */
;;;431      RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  6028              STR      r0,[r5,#0]
;;;432      
;;;433      return status;
000046  4630              MOV      r0,r6
;;;434    }
000048  bd70              POP      {r4-r6,pc}
;;;435    
                          ENDP

00004a  0000              DCW      0x0000
                  |L30.76|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1632     */
;;;1633   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  4b09              LDR      r3,|L31.40|
;;;1634   {
000002  b510              PUSH     {r4,lr}
;;;1635     /* Check the parameters */
;;;1636     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1637     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1638   
;;;1639     /* Disable the write protection for RTC registers */
;;;1640     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1641     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1642   
;;;1643     /* Clear the bits to be configured */
;;;1644     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000c  4a06              LDR      r2,|L31.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f42404e0          BIC      r4,r4,#0x700000
000016  6014              STR      r4,[r2,#0]
;;;1645   
;;;1646     /* Configure the output selection and polarity */
;;;1647     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1648   
;;;1649     /* Enable the write protection for RTC registers */
;;;1650     RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1651   }
000024  bd10              POP      {r4,pc}
;;;1652   
                          ENDP

000026  0000              DCW      0x0000
                  |L31.40|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2304     */
;;;2305   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4904              LDR      r1,|L32.20|
;;;2306   {
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2309     
;;;2310     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  680a              LDR      r2,[r1,#0]
000004  f4222280          BIC      r2,r2,#0x40000
000008  600a              STR      r2,[r1,#0]
;;;2311     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2312   }
000010  4770              BX       lr
;;;2313   
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2264     */
;;;2265   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b508              PUSH     {r3,lr}
;;;2266   {
;;;2267     __IO uint32_t tmp = 0;
;;;2268     
;;;2269     /* Check the parameters */
;;;2270     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2271   
;;;2272     tmp = RTC_BASE + 0x50;
000002  4903              LDR      r1,|L33.16|
;;;2273     tmp += (RTC_BKP_DR * 4);
000004  eb010080          ADD      r0,r1,r0,LSL #2
;;;2274     
;;;2275     /* Read the specified register */
;;;2276     return (*(__IO uint32_t *)tmp);
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
;;;2277   }
00000c  bd08              POP      {r3,pc}
;;;2278   
                          ENDP

00000e  0000              DCW      0x0000
                  |L33.16|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;600      */
;;;601    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;602    {
;;;603      ErrorStatus status = ERROR;
;;;604    
;;;605      /* Check the parameters */
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607    
;;;608      /* Disable the write protection for RTC registers */
;;;609      RTC->WPR = 0xCA;
000002  4c0d              LDR      r4,|L34.56|
000004  4606              MOV      r6,r0                 ;602
000006  2500              MOVS     r5,#0                 ;603
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;610      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;611    
;;;612      /* Set Initialization mode */
;;;613      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L34.48|
;;;614      {
;;;615        status = ERROR;
;;;616      }
;;;617      else
;;;618      {
;;;619        if (NewState != DISABLE)
;;;620        {
;;;621          /* Enable the RTC reference clock detection */
;;;622          RTC->CR |= RTC_CR_REFCKON;   
000016  4808              LDR      r0,|L34.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;623        }
;;;624        else
;;;625        {
;;;626          /* Disable the RTC reference clock detection */
;;;627          RTC->CR &= ~RTC_CR_REFCKON;    
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L34.36|
00001e  f0410110          ORR      r1,r1,#0x10           ;622
000022  e001              B        |L34.40|
                  |L34.36|
000024  f0210110          BIC      r1,r1,#0x10
                  |L34.40|
000028  6001              STR      r1,[r0,#0]
;;;628        }
;;;629        /* Exit Initialization mode */
;;;630        RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;631    
;;;632        status = SUCCESS;
00002e  2501              MOVS     r5,#1
                  |L34.48|
;;;633      }
;;;634    
;;;635      /* Enable the write protection for RTC registers */
;;;636      RTC->WPR = 0xFF;
000030  20ff              MOVS     r0,#0xff
000032  6020              STR      r0,[r4,#0]
;;;637    
;;;638      return status;
000034  4628              MOV      r0,r5
;;;639    }
000036  bd70              POP      {r4-r6,pc}
;;;640    
                          ENDP

                  |L34.56|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1053     */
;;;1054   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1055   {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;1056     uint32_t tmpreg = 0;
;;;1057     
;;;1058     /* Check the parameters */
;;;1059     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1060     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1061     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1062     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1063   
;;;1064     if (RTC_Format == RTC_Format_BIN)
;;;1065     {
;;;1066       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4a26              LDR      r2,|L35.160|
000008  2100              MOVS     r1,#0                 ;1055
00000a  2800              CMP      r0,#0                 ;1064
;;;1067       {
;;;1068         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1069         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1070       } 
;;;1071       else
;;;1072       {
;;;1073         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1074         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1075       }
;;;1076       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1077       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1078       
;;;1079       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1080       {
;;;1081         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1082       }
;;;1083       else
;;;1084       {
;;;1085         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1086       }
;;;1087     }
;;;1088     else
;;;1089     {
;;;1090       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000c  6810              LDR      r0,[r2,#0]
00000e  ea4f6040          LSL      r0,r0,#25
000012  d005              BEQ      |L35.32|
000014  2800              CMP      r0,#0
000016  da1c              BGE      |L35.82|
;;;1091       {
;;;1092         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000018  7820              LDRB     r0,[r4,#0]
00001a  f7fffffe          BL       RTC_Bcd2ToByte
;;;1093         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1094         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00001e  e019              B        |L35.84|
                  |L35.32|
000020  2800              CMP      r0,#0                 ;1066
000022  db00              BLT      |L35.38|
000024  70e1              STRB     r1,[r4,#3]            ;1073
                  |L35.38|
;;;1095       } 
;;;1096       else
;;;1097       {
;;;1098         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1099         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1100       }
;;;1101       
;;;1102       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1103       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1104       
;;;1105       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1106       {
;;;1107         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1108         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1109       }
;;;1110       else
;;;1111       {
;;;1112         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1113         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1114       }    
;;;1115     }
;;;1116   
;;;1117     /* Check the input parameters format */
;;;1118     if (RTC_Format != RTC_Format_BIN)
;;;1119     {
;;;1120       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
;;;1121                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1122                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1123                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1124                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1125                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1126                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1127     }  
;;;1128     else
;;;1129     {
;;;1130       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000026  7820              LDRB     r0,[r4,#0]
000028  f7fffffe          BL       RTC_ByteToBcd2
00002c  0406              LSLS     r6,r0,#16
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_ByteToBcd2
000034  ea462600          ORR      r6,r6,r0,LSL #8
000038  78a0              LDRB     r0,[r4,#2]
00003a  f7fffffe          BL       RTC_ByteToBcd2
00003e  4306              ORRS     r6,r6,r0
000040  78e0              LDRB     r0,[r4,#3]
000042  ea464600          ORR      r6,r6,r0,LSL #16
000046  7b20              LDRB     r0,[r4,#0xc]
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  ea466000          ORR      r0,r6,r0,LSL #24
000050  e010              B        |L35.116|
                  |L35.82|
000052  70e1              STRB     r1,[r4,#3]            ;1098
                  |L35.84|
000054  7b20              LDRB     r0,[r4,#0xc]          ;1107
000056  f7fffffe          BL       RTC_Bcd2ToByte
00005a  78a0              LDRB     r0,[r4,#2]            ;1120
00005c  7821              LDRB     r1,[r4,#0]            ;1120
00005e  78e2              LDRB     r2,[r4,#3]            ;1120
000060  ea404001          ORR      r0,r0,r1,LSL #16      ;1120
000064  7861              LDRB     r1,[r4,#1]            ;1120
000066  0209              LSLS     r1,r1,#8              ;1120
000068  ea414102          ORR      r1,r1,r2,LSL #16      ;1120
00006c  4308              ORRS     r0,r0,r1              ;1120
00006e  7b21              LDRB     r1,[r4,#0xc]          ;1120
000070  ea406001          ORR      r0,r0,r1,LSL #24      ;1120
                  |L35.116|
000074  68a1              LDR      r1,[r4,#8]
;;;1131                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1132                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1133                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1134                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1135                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1136                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1137     } 
;;;1138   
;;;1139     /* Disable the write protection for RTC registers */
;;;1140     RTC->WPR = 0xCA;
000076  4a0a              LDR      r2,|L35.160|
000078  4308              ORRS     r0,r0,r1              ;1130
00007a  6861              LDR      r1,[r4,#4]            ;1130
00007c  4308              ORRS     r0,r0,r1              ;1130
00007e  21ca              MOVS     r1,#0xca
000080  321c              ADDS     r2,r2,#0x1c
000082  6011              STR      r1,[r2,#0]
;;;1141     RTC->WPR = 0x53;
000084  2153              MOVS     r1,#0x53
000086  6011              STR      r1,[r2,#0]
;;;1142   
;;;1143     /* Configure the Alarm register */
;;;1144     if (RTC_Alarm == RTC_Alarm_A)
000088  f5b57f80          CMP      r5,#0x100
00008c  d004              BEQ      |L35.152|
;;;1145     {
;;;1146       RTC->ALRMAR = (uint32_t)tmpreg;
;;;1147     }
;;;1148     else
;;;1149     {
;;;1150       RTC->ALRMBR = (uint32_t)tmpreg;
00008e  1f11              SUBS     r1,r2,#4
                  |L35.144|
000090  6008              STR      r0,[r1,#0]
;;;1151     }
;;;1152   
;;;1153     /* Enable the write protection for RTC registers */
;;;1154     RTC->WPR = 0xFF;   
000092  20ff              MOVS     r0,#0xff
000094  6010              STR      r0,[r2,#0]
;;;1155   }
000096  bd70              POP      {r4-r6,pc}
                  |L35.152|
000098  4901              LDR      r1,|L35.160|
00009a  3114              ADDS     r1,r1,#0x14           ;1146
00009c  e7f8              B        |L35.144|
;;;1156   
                          ENDP

00009e  0000              DCW      0x0000
                  |L35.160|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;883      */
;;;884    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;885    {
000002  460c              MOV      r4,r1
000004  0001              MOVS     r1,r0
;;;886      uint32_t tmpreg = 0;
;;;887      ErrorStatus status = ERROR;
;;;888      
;;;889      /* Check the parameters */
;;;890      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;891    
;;;892      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
000006  7860              LDRB     r0,[r4,#1]
000008  f04f0600          MOV      r6,#0                 ;887
00000c  d02a              BEQ      |L36.100|
;;;893      {
;;;894        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;895      }  
;;;896      if (RTC_Format == RTC_Format_BIN)
;;;897      {
;;;898        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;899        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;900        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;901      }
;;;902      else
;;;903      {
;;;904        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;905        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00000e  f7fffffe          BL       RTC_Bcd2ToByte
;;;906        assert_param(IS_RTC_MONTH(tmpreg));
;;;907        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000012  78a0              LDRB     r0,[r4,#2]
000014  f7fffffe          BL       RTC_Bcd2ToByte
;;;908        assert_param(IS_RTC_DATE(tmpreg));
;;;909      }
;;;910      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;911    
;;;912      /* Check the input parameters format */
;;;913      if (RTC_Format != RTC_Format_BIN)
;;;914      {
;;;915        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000018  78a0              LDRB     r0,[r4,#2]
00001a  78e1              LDRB     r1,[r4,#3]
00001c  ea404501          ORR      r5,r0,r1,LSL #16
000020  7860              LDRB     r0,[r4,#1]
000022  7821              LDRB     r1,[r4,#0]
000024  0200              LSLS     r0,r0,#8
000026  ea403041          ORR      r0,r0,r1,LSL #13
00002a  4305              ORRS     r5,r5,r0
                  |L36.44|
;;;916                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;917                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;918                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;919      }  
;;;920      else
;;;921      {
;;;922        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
;;;923                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;924                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;925                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;926      }
;;;927    
;;;928      /* Disable the write protection for RTC registers */
;;;929      RTC->WPR = 0xCA;
00002c  4c19              LDR      r4,|L36.148|
00002e  20ca              MOVS     r0,#0xca
000030  6020              STR      r0,[r4,#0]
;;;930      RTC->WPR = 0x53;
000032  2053              MOVS     r0,#0x53
000034  6020              STR      r0,[r4,#0]
;;;931    
;;;932      /* Set Initialization mode */
;;;933      if (RTC_EnterInitMode() == ERROR)
000036  f7fffffe          BL       RTC_EnterInitMode
00003a  b178              CBZ      r0,|L36.92|
;;;934      {
;;;935        status = ERROR;
;;;936      } 
;;;937      else
;;;938      {
;;;939        /* Set the RTC_DR register */
;;;940        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00003c  4816              LDR      r0,|L36.152|
00003e  4005              ANDS     r5,r5,r0
000040  4814              LDR      r0,|L36.148|
000042  3820              SUBS     r0,r0,#0x20
000044  6005              STR      r5,[r0,#0]
;;;941    
;;;942        /* Exit Initialization mode */
;;;943        RTC_ExitInitMode(); 
000046  f7fffffe          BL       RTC_ExitInitMode
;;;944    
;;;945        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;946        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
00004a  4812              LDR      r0,|L36.148|
00004c  381c              SUBS     r0,r0,#0x1c
00004e  6800              LDR      r0,[r0,#0]
000050  0680              LSLS     r0,r0,#26
000052  d402              BMI      |L36.90|
;;;947        {
;;;948          if (RTC_WaitForSynchro() == ERROR)
000054  f7fffffe          BL       RTC_WaitForSynchro
000058  b100              CBZ      r0,|L36.92|
                  |L36.90|
;;;949          {
;;;950            status = ERROR;
;;;951          }
;;;952          else
;;;953          {
;;;954            status = SUCCESS;
;;;955          }
;;;956        }
;;;957        else
;;;958        {
;;;959          status = SUCCESS;
00005a  2601              MOVS     r6,#1
                  |L36.92|
;;;960        }
;;;961      }
;;;962      /* Enable the write protection for RTC registers */
;;;963      RTC->WPR = 0xFF;
00005c  20ff              MOVS     r0,#0xff
00005e  6020              STR      r0,[r4,#0]
;;;964      
;;;965      return status;
000060  4630              MOV      r0,r6
;;;966    }
000062  bd70              POP      {r4-r6,pc}
                  |L36.100|
000064  06c1              LSLS     r1,r0,#27             ;892
000066  d503              BPL      |L36.112|
000068  f0200010          BIC      r0,r0,#0x10           ;894
00006c  300a              ADDS     r0,r0,#0xa            ;894
00006e  7060              STRB     r0,[r4,#1]            ;894
                  |L36.112|
000070  78e0              LDRB     r0,[r4,#3]            ;922
000072  f7fffffe          BL       RTC_ByteToBcd2
000076  0405              LSLS     r5,r0,#16             ;922
000078  7860              LDRB     r0,[r4,#1]            ;922
00007a  f7fffffe          BL       RTC_ByteToBcd2
00007e  ea452500          ORR      r5,r5,r0,LSL #8       ;922
000082  78a0              LDRB     r0,[r4,#2]            ;922
000084  f7fffffe          BL       RTC_ByteToBcd2
000088  4305              ORRS     r5,r5,r0              ;922
00008a  7820              LDRB     r0,[r4,#0]            ;922
00008c  ea453540          ORR      r5,r5,r0,LSL #13      ;922
000090  e7cc              B        |L36.44|
;;;967    
                          ENDP

000092  0000              DCW      0x0000
                  |L36.148|
                          DCD      0x40002824
                  |L36.152|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;702      */
;;;703    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;704    {
;;;705      uint32_t tmpreg = 0;
;;;706      ErrorStatus status = ERROR;
;;;707        
;;;708      /* Check the parameters */
;;;709      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;710      
;;;711      if (RTC_Format == RTC_Format_BIN)
;;;712      {
;;;713        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000004  4f24              LDR      r7,|L37.152|
000006  460c              MOV      r4,r1                 ;704
000008  0002              MOVS     r2,r0                 ;704
00000a  f04f0600          MOV      r6,#0                 ;706
;;;714        {
;;;715          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;716          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;717        } 
;;;718        else
;;;719        {
;;;720          RTC_TimeStruct->RTC_H12 = 0x00;
;;;721          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;722        }
;;;723        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;724        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;725      }
;;;726      else
;;;727      {
;;;728        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;729        {
;;;730          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00000e  7820              LDRB     r0,[r4,#0]
000010  683a              LDR      r2,[r7,#0]            ;728
000012  4631              MOV      r1,r6                 ;706
000014  ea4f6242          LSL      r2,r2,#25             ;728
000018  d004              BEQ      |L37.36|
00001a  2a00              CMP      r2,#0                 ;728
00001c  da15              BGE      |L37.74|
00001e  f7fffffe          BL       RTC_Bcd2ToByte
;;;731          assert_param(IS_RTC_HOUR12(tmpreg));
;;;732          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
000022  e013              B        |L37.76|
                  |L37.36|
000024  2a00              CMP      r2,#0                 ;713
000026  db00              BLT      |L37.42|
000028  70e1              STRB     r1,[r4,#3]            ;720
                  |L37.42|
;;;733        } 
;;;734        else
;;;735        {
;;;736          RTC_TimeStruct->RTC_H12 = 0x00;
;;;737          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;738        }
;;;739        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;740        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;741      }
;;;742      
;;;743      /* Check the input parameters format */
;;;744      if (RTC_Format != RTC_Format_BIN)
;;;745      {
;;;746        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;747                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;748                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;749                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;750      }  
;;;751      else
;;;752      {
;;;753        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
00002a  f7fffffe          BL       RTC_ByteToBcd2
00002e  0405              LSLS     r5,r0,#16
000030  7860              LDRB     r0,[r4,#1]
000032  f7fffffe          BL       RTC_ByteToBcd2
000036  ea452500          ORR      r5,r5,r0,LSL #8
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f7fffffe          BL       RTC_ByteToBcd2
000040  4305              ORRS     r5,r5,r0
000042  78e0              LDRB     r0,[r4,#3]
000044  ea454500          ORR      r5,r5,r0,LSL #16
000048  e00a              B        |L37.96|
                  |L37.74|
00004a  70e1              STRB     r1,[r4,#3]            ;736
                  |L37.76|
00004c  78a0              LDRB     r0,[r4,#2]            ;746
00004e  7821              LDRB     r1,[r4,#0]            ;746
000050  ea404501          ORR      r5,r0,r1,LSL #16      ;746
000054  7860              LDRB     r0,[r4,#1]            ;746
000056  78e1              LDRB     r1,[r4,#3]            ;746
000058  0200              LSLS     r0,r0,#8              ;746
00005a  ea404001          ORR      r0,r0,r1,LSL #16      ;746
00005e  4305              ORRS     r5,r5,r0              ;746
                  |L37.96|
;;;754                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;755                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;756                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;757      }  
;;;758    
;;;759      /* Disable the write protection for RTC registers */
;;;760      RTC->WPR = 0xCA;
000060  4c0d              LDR      r4,|L37.152|
000062  20ca              MOVS     r0,#0xca
000064  341c              ADDS     r4,r4,#0x1c
000066  6020              STR      r0,[r4,#0]
;;;761      RTC->WPR = 0x53;
000068  2053              MOVS     r0,#0x53
00006a  6020              STR      r0,[r4,#0]
;;;762    
;;;763      /* Set Initialization mode */
;;;764      if (RTC_EnterInitMode() == ERROR)
00006c  f7fffffe          BL       RTC_EnterInitMode
000070  b168              CBZ      r0,|L37.142|
;;;765      {
;;;766        status = ERROR;
;;;767      } 
;;;768      else
;;;769      {
;;;770        /* Set the RTC_TR register */
;;;771        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000072  480a              LDR      r0,|L37.156|
000074  4005              ANDS     r5,r5,r0
000076  4808              LDR      r0,|L37.152|
000078  3808              SUBS     r0,r0,#8
00007a  6005              STR      r5,[r0,#0]
;;;772    
;;;773        /* Exit Initialization mode */
;;;774        RTC_ExitInitMode(); 
00007c  f7fffffe          BL       RTC_ExitInitMode
;;;775    
;;;776        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;777        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000080  6838              LDR      r0,[r7,#0]
000082  0680              LSLS     r0,r0,#26
000084  d402              BMI      |L37.140|
;;;778        {
;;;779          if (RTC_WaitForSynchro() == ERROR)
000086  f7fffffe          BL       RTC_WaitForSynchro
00008a  b100              CBZ      r0,|L37.142|
                  |L37.140|
;;;780          {
;;;781            status = ERROR;
;;;782          }
;;;783          else
;;;784          {
;;;785            status = SUCCESS;
;;;786          }
;;;787        }
;;;788        else
;;;789        {
;;;790          status = SUCCESS;
00008c  2601              MOVS     r6,#1
                  |L37.142|
;;;791        }
;;;792      
;;;793      }
;;;794      /* Enable the write protection for RTC registers */
;;;795      RTC->WPR = 0xFF;
00008e  20ff              MOVS     r0,#0xff
000090  6020              STR      r0,[r4,#0]
;;;796        
;;;797      return status;
000092  4630              MOV      r0,r6
;;;798    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;799    
                          ENDP

                  |L37.152|
                          DCD      0x40002808
                  |L37.156|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1458     */
;;;1459   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  4905              LDR      r1,|L38.24|
;;;1460   {
;;;1461     /* Check the parameters */
;;;1462     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1463     
;;;1464     /* Disable the write protection for RTC registers */
;;;1465     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  600a              STR      r2,[r1,#0]
;;;1466     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  600a              STR      r2,[r1,#0]
;;;1467     
;;;1468     /* Configure the Wakeup Timer counter */
;;;1469     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4a03              LDR      r2,|L38.24|
00000c  3a10              SUBS     r2,r2,#0x10
00000e  6010              STR      r0,[r2,#0]
;;;1470     
;;;1471     /* Enable the write protection for RTC registers */
;;;1472     RTC->WPR = 0xFF;
000010  20ff              MOVS     r0,#0xff
000012  6008              STR      r0,[r1,#0]
;;;1473   }
000014  4770              BX       lr
;;;1474   
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40002824

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1839   */
;;;1840   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1841                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1842                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1843   {
;;;1844     ErrorStatus status = ERROR;
;;;1845     uint32_t recalpfcount = 0;
;;;1846   
;;;1847     /* Check the parameters */
;;;1848     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1849     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1850     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1851   
;;;1852     /* Disable the write protection for RTC registers */
;;;1853     RTC->WPR = 0xCA;
000002  4b10              LDR      r3,|L39.68|
000004  2400              MOVS     r4,#0                 ;1845
000006  25ca              MOVS     r5,#0xca
000008  601d              STR      r5,[r3,#0]
;;;1854     RTC->WPR = 0x53;
00000a  2553              MOVS     r5,#0x53
00000c  601d              STR      r5,[r3,#0]
;;;1855     
;;;1856     /* check if a calibration is pending*/
;;;1857     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
00000e  4d0d              LDR      r5,|L39.68|
000010  3d18              SUBS     r5,r5,#0x18
000012  682e              LDR      r6,[r5,#0]
000014  03f6              LSLS     r6,r6,#15
000016  d507              BPL      |L39.40|
;;;1858     {
;;;1859       /* wait until the Calibration is completed*/
;;;1860       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000018  149e              ASRS     r6,r3,#18
                  |L39.26|
00001a  682f              LDR      r7,[r5,#0]
00001c  03ff              LSLS     r7,r7,#15
00001e  d503              BPL      |L39.40|
000020  42b4              CMP      r4,r6
000022  d001              BEQ      |L39.40|
000024  1c64              ADDS     r4,r4,#1
;;;1861       {
;;;1862         recalpfcount++;
000026  e7f8              B        |L39.26|
                  |L39.40|
;;;1863       }
;;;1864     }
;;;1865   
;;;1866     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1867     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000028  682c              LDR      r4,[r5,#0]
00002a  03e4              LSLS     r4,r4,#15
00002c  d406              BMI      |L39.60|
;;;1868     {
;;;1869       /* Configure the Smooth calibration settings */
;;;1870       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
00002e  4308              ORRS     r0,r0,r1
000030  4904              LDR      r1,|L39.68|
000032  4310              ORRS     r0,r0,r2
000034  3118              ADDS     r1,r1,#0x18
000036  6008              STR      r0,[r1,#0]
;;;1871   
;;;1872       status = SUCCESS;
000038  2001              MOVS     r0,#1
00003a  e000              B        |L39.62|
                  |L39.60|
;;;1873     }
;;;1874     else
;;;1875     {
;;;1876       status = ERROR;
00003c  2000              MOVS     r0,#0
                  |L39.62|
;;;1877     }
;;;1878   
;;;1879     /* Enable the write protection for RTC registers */
;;;1880     RTC->WPR = 0xFF;
00003e  21ff              MOVS     r1,#0xff
000040  6019              STR      r1,[r3,#0]
;;;1881     
;;;1882     return (ErrorStatus)(status);
;;;1883   }
000042  bdf0              POP      {r4-r7,pc}
;;;1884   
                          ENDP

                  |L39.68|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;441      */
;;;442    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;443    {
;;;444      /* Initialize the RTC_HourFormat member */
;;;445      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;446        
;;;447      /* Initialize the RTC_AsynchPrediv member */
;;;448      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000002  6001              STR      r1,[r0,#0]
000004  217f              MOVS     r1,#0x7f
;;;449    
;;;450      /* Initialize the RTC_SynchPrediv member */
;;;451      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000006  6041              STR      r1,[r0,#4]
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;452    }
00000c  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2342   */
;;;2343   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b570              PUSH     {r4-r6,lr}
;;;2344   {
;;;2345     ErrorStatus status = ERROR;
;;;2346     uint32_t shpfcount = 0;
;;;2347   
;;;2348     /* Check the parameters */
;;;2349     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2350     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2351   
;;;2352     /* Disable the write protection for RTC registers */
;;;2353     RTC->WPR = 0xCA;
000002  4c14              LDR      r4,|L41.84|
000004  2200              MOVS     r2,#0                 ;2346
000006  23ca              MOVS     r3,#0xca
000008  6023              STR      r3,[r4,#0]
;;;2354     RTC->WPR = 0x53;
00000a  2353              MOVS     r3,#0x53
00000c  6023              STR      r3,[r4,#0]
;;;2355     
;;;2356     /* Check if a Shift is pending*/
;;;2357     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
00000e  4b11              LDR      r3,|L41.84|
000010  3b18              SUBS     r3,r3,#0x18
000012  681d              LDR      r5,[r3,#0]
000014  072d              LSLS     r5,r5,#28
000016  d507              BPL      |L41.40|
;;;2358     {
;;;2359       /* Wait until the shift is completed*/
;;;2360       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000018  145d              ASRS     r5,r3,#17
                  |L41.26|
00001a  681e              LDR      r6,[r3,#0]
00001c  0736              LSLS     r6,r6,#28
00001e  d503              BPL      |L41.40|
000020  42aa              CMP      r2,r5
000022  d001              BEQ      |L41.40|
000024  1c52              ADDS     r2,r2,#1
;;;2361       {
;;;2362         shpfcount++;
000026  e7f8              B        |L41.26|
                  |L41.40|
;;;2363       }
;;;2364     }
;;;2365   
;;;2366     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2367     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000028  681a              LDR      r2,[r3,#0]
00002a  0712              LSLS     r2,r2,#28
00002c  d40d              BMI      |L41.74|
;;;2368     {
;;;2369       /* check if the reference clock detection is disabled */
;;;2370       if((RTC->CR & RTC_CR_REFCKON) == RESET)
00002e  4a09              LDR      r2,|L41.84|
000030  3a1c              SUBS     r2,r2,#0x1c
000032  6812              LDR      r2,[r2,#0]
000034  06d2              LSLS     r2,r2,#27
000036  d408              BMI      |L41.74|
;;;2371       {
;;;2372         /* Configure the Shift settings */
;;;2373         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
000038  4301              ORRS     r1,r1,r0
00003a  4806              LDR      r0,|L41.84|
00003c  3008              ADDS     r0,r0,#8
00003e  6001              STR      r1,[r0,#0]
;;;2374       
;;;2375         if(RTC_WaitForSynchro() == ERROR)
000040  f7fffffe          BL       RTC_WaitForSynchro
000044  b110              CBZ      r0,|L41.76|
;;;2376         {
;;;2377           status = ERROR;
;;;2378         }
;;;2379         else
;;;2380         {
;;;2381           status = SUCCESS;
000046  2001              MOVS     r0,#1
000048  e000              B        |L41.76|
                  |L41.74|
;;;2382         }
;;;2383       }
;;;2384       else
;;;2385       {
;;;2386         status = ERROR;
00004a  2000              MOVS     r0,#0
                  |L41.76|
;;;2387       }
;;;2388     }
;;;2389     else
;;;2390     {
;;;2391       status = ERROR;
;;;2392     }
;;;2393   
;;;2394     /* Enable the write protection for RTC registers */
;;;2395     RTC->WPR = 0xFF;
00004c  21ff              MOVS     r1,#0xff
00004e  6021              STR      r1,[r4,#0]
;;;2396     
;;;2397     return (ErrorStatus)(status);
;;;2398   }
000050  bd70              POP      {r4-r6,pc}
;;;2399   
                          ENDP

000052  0000              DCW      0x0000
                  |L41.84|
                          DCD      0x40002824

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;2071     */
;;;2072   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  4a04              LDR      r2,|L42.20|
;;;2073   {
;;;2074     /* Check the parameters */
;;;2075     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2076     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2077     
;;;2078     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2079     {
;;;2080       /* Enable the selected Tamper pin */
;;;2081       RTC->TAFCR |= (uint32_t)RTC_Tamper;
;;;2082     }
;;;2083     else
;;;2084     {
;;;2085       /* Disable the selected Tamper pin */
;;;2086       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L42.12|
000008  4301              ORRS     r1,r1,r0              ;2081
00000a  e000              B        |L42.14|
                  |L42.12|
00000c  4381              BICS     r1,r1,r0
                  |L42.14|
00000e  6011              STR      r1,[r2,#0]            ;2081
;;;2087     }  
;;;2088   }
000010  4770              BX       lr
;;;2089   
                          ENDP

000012  0000              DCW      0x0000
                  |L42.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2102     */
;;;2103   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4904              LDR      r1,|L43.20|
;;;2104   {
;;;2105     /* Check the parameters */
;;;2106     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2107      
;;;2108     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2109     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  680a              LDR      r2,[r1,#0]
000004  f42252c0          BIC      r2,r2,#0x1800
000008  600a              STR      r2,[r1,#0]
;;;2110   
;;;2111     /* Configure the RTC_TAFCR register */
;;;2112     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2113   }
000010  4770              BX       lr
;;;2114   
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2159     */
;;;2160   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4904              LDR      r1,|L44.20|
;;;2161   {
;;;2162     /* Check the parameters */
;;;2163     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2164      
;;;2165     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2166     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  680a              LDR      r2,[r1,#0]
000004  f42242c0          BIC      r2,r2,#0x6000
000008  600a              STR      r2,[r1,#0]
;;;2167   
;;;2168     /* Configure the RTC_TAFCR register */
;;;2169     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2170   }
000010  4770              BX       lr
;;;2171   
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2202     */
;;;2203   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L45.24|
;;;2204   {
;;;2205     /* Check the parameters */
;;;2206     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2207     
;;;2208    if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2209     {
;;;2210       /* Enable precharge of the selected Tamper pin */
;;;2211       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
;;;2212     }
;;;2213     else
;;;2214     {
;;;2215       /* Disable precharge of the selected Tamper pin */
;;;2216       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L45.14|
000008  f4204000          BIC      r0,r0,#0x8000         ;2211
00000c  e001              B        |L45.18|
                  |L45.14|
00000e  f4404000          ORR      r0,r0,#0x8000
                  |L45.18|
000012  6008              STR      r0,[r1,#0]            ;2211
;;;2217     } 
;;;2218   }
000014  4770              BX       lr
;;;2219   
                          ENDP

000016  0000              DCW      0x0000
                  |L45.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2136     */
;;;2137   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4904              LDR      r1,|L46.20|
;;;2138   {
;;;2139     /* Check the parameters */
;;;2140     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2141    
;;;2142     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2143     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  680a              LDR      r2,[r1,#0]
000004  f42262e0          BIC      r2,r2,#0x700
000008  600a              STR      r2,[r1,#0]
;;;2144   
;;;2145     /* Configure the RTC_TAFCR register */
;;;2146     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2147   }
000010  4770              BX       lr
;;;2148   
                          ENDP

000012  0000              DCW      0x0000
                  |L46.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;2041     */
;;;2042   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  4a05              LDR      r2,|L47.24|
;;;2043   {
;;;2044     /* Check the parameters */
;;;2045     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;2046     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2047    
;;;2048     /* Check if the  active level for Tamper is rising edge (Low level)*/
;;;2049     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
000002  2900              CMP      r1,#0
;;;2050     {  
;;;2051       /* Configure the RTC_TAFCR register */
;;;2052       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
;;;2053     }
;;;2054     else
;;;2055     { 
;;;2056       /* Configure the RTC_TAFCR register */
;;;2057       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000004  6811              LDR      r1,[r2,#0]
000006  d003              BEQ      |L47.16|
000008  ea410040          ORR      r0,r1,r0,LSL #1
                  |L47.12|
00000c  6010              STR      r0,[r2,#0]            ;2052
;;;2058     }  
;;;2059   }
00000e  4770              BX       lr
                  |L47.16|
000010  ea210040          BIC      r0,r1,r0,LSL #1       ;2052
000014  e7fa              B        |L47.12|
;;;2060   
                          ENDP

000016  0000              DCW      0x0000
                  |L47.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1915     */
;;;1916   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  4b0a              LDR      r3,|L48.44|
;;;1917   {
000002  b510              PUSH     {r4,lr}
;;;1918     uint32_t tmpreg = 0;
;;;1919   
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1922     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1923   
;;;1924     /* Get the RTC_CR register and clear the bits to be configured */
;;;1925     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000004  681a              LDR      r2,[r3,#0]
000006  f6400408          MOV      r4,#0x808
00000a  43a2              BICS     r2,r2,r4
;;;1926   
;;;1927     /* Get the new configuration */
;;;1928     if (NewState != DISABLE)
;;;1929     {
;;;1930       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1931     }
;;;1932     else
;;;1933     {
;;;1934       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00000c  ea420200          ORR      r2,r2,r0
000010  b109              CBZ      r1,|L48.22|
000012  f4426200          ORR      r2,r2,#0x800          ;1930
                  |L48.22|
;;;1935     }
;;;1936   
;;;1937     /* Disable the write protection for RTC registers */
;;;1938     RTC->WPR = 0xCA;
000016  4805              LDR      r0,|L48.44|
000018  21ca              MOVS     r1,#0xca
00001a  301c              ADDS     r0,r0,#0x1c
00001c  6001              STR      r1,[r0,#0]
;;;1939     RTC->WPR = 0x53;
00001e  2153              MOVS     r1,#0x53
000020  6001              STR      r1,[r0,#0]
;;;1940   
;;;1941     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1942     RTC->CR = (uint32_t)tmpreg;
000022  601a              STR      r2,[r3,#0]
;;;1943   
;;;1944     /* Enable the write protection for RTC registers */
;;;1945     RTC->WPR = 0xFF;
000024  21ff              MOVS     r1,#0xff
000026  6001              STR      r1,[r0,#0]
;;;1946   }
000028  bd10              POP      {r4,pc}
;;;1947   
                          ENDP

00002a  0000              DCW      0x0000
                  |L48.44|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2179     */
;;;2180   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L49.24|
;;;2181   {
;;;2182     /* Check the parameters */
;;;2183     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2184      
;;;2185     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2186     {
;;;2187       /* Save timestamp on tamper detection event */
;;;2188       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
;;;2189     }
;;;2190     else
;;;2191     {
;;;2192       /* Tamper detection does not cause a timestamp to be saved */
;;;2193       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L49.14|
000008  f0400080          ORR      r0,r0,#0x80           ;2188
00000c  e001              B        |L49.18|
                  |L49.14|
00000e  f0200080          BIC      r0,r0,#0x80
                  |L49.18|
000012  6008              STR      r0,[r1,#0]            ;2188
;;;2194     }
;;;2195   }
000014  4770              BX       lr
;;;2196   
                          ENDP

000016  0000              DCW      0x0000
                  |L49.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;806      */
;;;807    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;808    {
;;;809      /* Time = 00h:00min:00sec */
;;;810      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;811      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;812      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;813      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;814    }
00000a  4770              BX       lr
;;;815    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;557      */
;;;558    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;559    {
;;;560      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;561      ErrorStatus status = ERROR;
;;;562      uint32_t synchrostatus = 0x00;
;;;563    
;;;564      /* Disable the write protection for RTC registers */
;;;565      RTC->WPR = 0xCA;
000004  490f              LDR      r1,|L51.68|
000006  9000              STR      r0,[sp,#0]
000008  20ca              MOVS     r0,#0xca
00000a  6008              STR      r0,[r1,#0]
;;;566      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6008              STR      r0,[r1,#0]
;;;567        
;;;568      /* Clear RSF flag */
;;;569      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000010  480c              LDR      r0,|L51.68|
000012  3818              SUBS     r0,r0,#0x18
000014  6802              LDR      r2,[r0,#0]
000016  f02202a0          BIC      r2,r2,#0xa0
00001a  6002              STR      r2,[r0,#0]
;;;570        
;;;571      /* Wait the registers to be synchronised */
;;;572      do
;;;573      {
;;;574        synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;575        synchrocounter++;  
;;;576      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
00001c  13c4              ASRS     r4,r0,#15
                  |L51.30|
00001e  6802              LDR      r2,[r0,#0]            ;574
000020  9b00              LDR      r3,[sp,#0]            ;575
000022  f0020220          AND      r2,r2,#0x20           ;574
000026  1c5b              ADDS     r3,r3,#1              ;575
000028  9300              STR      r3,[sp,#0]
00002a  42a3              CMP      r3,r4
00002c  d001              BEQ      |L51.50|
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L51.30|
                  |L51.50|
;;;577        
;;;578      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000032  6800              LDR      r0,[r0,#0]
000034  0680              LSLS     r0,r0,#26
000036  d501              BPL      |L51.60|
;;;579      {
;;;580        status = SUCCESS;
000038  2001              MOVS     r0,#1
00003a  e000              B        |L51.62|
                  |L51.60|
;;;581      }
;;;582      else
;;;583      {
;;;584        status = ERROR;
00003c  2000              MOVS     r0,#0
                  |L51.62|
;;;585      }
;;;586    
;;;587      /* Enable the write protection for RTC registers */
;;;588      RTC->WPR = 0xFF;
00003e  22ff              MOVS     r2,#0xff
000040  600a              STR      r2,[r1,#0]
;;;589        
;;;590      return (status);
;;;591    }
000042  bd18              POP      {r3,r4,pc}
;;;592    
                          ENDP

                  |L51.68|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1431     */
;;;1432   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  4a08              LDR      r2,|L52.36|
;;;1433   {
;;;1434     /* Check the parameters */
;;;1435     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1436   
;;;1437     /* Disable the write protection for RTC registers */
;;;1438     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1439     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1440   
;;;1441     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1442     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4906              LDR      r1,|L52.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f0230307          BIC      r3,r3,#7
000014  600b              STR      r3,[r1,#0]
;;;1443   
;;;1444     /* Configure the clock source */
;;;1445     RTC->CR |= (uint32_t)RTC_WakeUpClock;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1446     
;;;1447     /* Enable the write protection for RTC registers */
;;;1448     RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1449   }
000020  4770              BX       lr
;;;1450   
                          ENDP

000022  0000              DCW      0x0000
                  |L52.36|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1491     */
;;;1492   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;1493   {
;;;1494     __IO uint32_t wutcounter = 0x00;
000002  2100              MOVS     r1,#0
;;;1495     uint32_t wutwfstatus = 0x00;
;;;1496     ErrorStatus status = ERROR;
;;;1497     
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1500   
;;;1501     /* Disable the write protection for RTC registers */
;;;1502     RTC->WPR = 0xCA;
000004  4a13              LDR      r2,|L53.84|
000006  9100              STR      r1,[sp,#0]
000008  21ca              MOVS     r1,#0xca
00000a  6011              STR      r1,[r2,#0]
;;;1503     RTC->WPR = 0x53;
00000c  2153              MOVS     r1,#0x53
00000e  6011              STR      r1,[r2,#0]
;;;1504   
;;;1505     if (NewState != DISABLE)
;;;1506     {
;;;1507       /* Enable the Wakeup Timer */
;;;1508       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000010  4910              LDR      r1,|L53.84|
000012  391c              SUBS     r1,r1,#0x1c
000014  2800              CMP      r0,#0                 ;1505
;;;1509       status = SUCCESS;    
;;;1510     }
;;;1511     else
;;;1512     {
;;;1513       /* Disable the Wakeup Timer */
;;;1514       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
000016  6808              LDR      r0,[r1,#0]
000018  d003              BEQ      |L53.34|
00001a  f4406080          ORR      r0,r0,#0x400          ;1508
00001e  6008              STR      r0,[r1,#0]            ;1508
000020  e014              B        |L53.76|
                  |L53.34|
000022  f4206080          BIC      r0,r0,#0x400
000026  6008              STR      r0,[r1,#0]
;;;1515       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1516       do
;;;1517       {
;;;1518         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000028  480a              LDR      r0,|L53.84|
00002a  3818              SUBS     r0,r0,#0x18
;;;1519         wutcounter++;  
;;;1520       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00002c  1444              ASRS     r4,r0,#17
                  |L53.46|
00002e  6801              LDR      r1,[r0,#0]            ;1518
000030  9b00              LDR      r3,[sp,#0]            ;1519
000032  f0010104          AND      r1,r1,#4              ;1518
000036  1c5b              ADDS     r3,r3,#1              ;1519
000038  9300              STR      r3,[sp,#0]
00003a  42a3              CMP      r3,r4
00003c  d001              BEQ      |L53.66|
00003e  2900              CMP      r1,#0
000040  d0f5              BEQ      |L53.46|
                  |L53.66|
;;;1521       
;;;1522       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000042  6800              LDR      r0,[r0,#0]
000044  0740              LSLS     r0,r0,#29
000046  d401              BMI      |L53.76|
;;;1523       {
;;;1524         status = ERROR;
000048  2000              MOVS     r0,#0
00004a  e000              B        |L53.78|
                  |L53.76|
;;;1525       }
;;;1526       else
;;;1527       {
;;;1528         status = SUCCESS;
00004c  2001              MOVS     r0,#1
                  |L53.78|
;;;1529       }    
;;;1530     }
;;;1531   
;;;1532     /* Enable the write protection for RTC registers */
;;;1533     RTC->WPR = 0xFF;
00004e  21ff              MOVS     r1,#0xff
000050  6011              STR      r1,[r2,#0]
;;;1534     
;;;1535     return status;
;;;1536   }
000052  bd18              POP      {r3,r4,pc}
;;;1537   
                          ENDP

                  |L53.84|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2243     */
;;;2244   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;2245   {
;;;2246     __IO uint32_t tmp = 0;
;;;2247     
;;;2248     /* Check the parameters */
;;;2249     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2250   
;;;2251     tmp = RTC_BASE + 0x50;
000002  4a03              LDR      r2,|L54.16|
;;;2252     tmp += (RTC_BKP_DR * 4);
000004  eb020080          ADD      r0,r2,r0,LSL #2
;;;2253   
;;;2254     /* Write the specified register */
;;;2255     *(__IO uint32_t *)tmp = (uint32_t)Data;
000008  9000              STR      r0,[sp,#0]
00000a  6001              STR      r1,[r0,#0]
;;;2256   }
00000c  bd08              POP      {r3,pc}
;;;2257   
                          ENDP

00000e  0000              DCW      0x0000
                  |L54.16|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;463      */
;;;464    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L55.20|
;;;465    {
000002  b108              CBZ      r0,|L55.8|
;;;466      /* Check the parameters */
;;;467      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;468        
;;;469      if (NewState != DISABLE)
;;;470      {
;;;471        /* Enable the write protection for RTC registers */
;;;472        RTC->WPR = 0xFF;   
000004  20ff              MOVS     r0,#0xff
000006  e002              B        |L55.14|
                  |L55.8|
;;;473      }
;;;474      else
;;;475      {
;;;476        /* Disable the write protection for RTC registers */
;;;477        RTC->WPR = 0xCA;
000008  20ca              MOVS     r0,#0xca
00000a  6008              STR      r0,[r1,#0]
;;;478        RTC->WPR = 0x53;    
00000c  2053              MOVS     r0,#0x53
                  |L55.14|
00000e  6008              STR      r0,[r1,#0]            ;472
;;;479      }
;;;480    }
000010  4770              BX       lr
;;;481    
                          ENDP

000012  0000              DCW      0x0000
                  |L55.20|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_rtc_c_81435638____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_rtc_c_81435638____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_rtc_c_81435638____REVSH|
#line 144
|__asm___15_stm32l1xx_rtc_c_81435638____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
