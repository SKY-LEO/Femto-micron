; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\test.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\test.d --feedback=.\STM32L152-EVAL\STM32L152-EVAL.fed --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\test.crf ..\src\test.c]
                          THUMB

                          AREA ||i.Display_Init||, CODE, READONLY, ALIGN=2

                  Display_Init PROC
;;;75      */
;;;76     void Display_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;77     {
;;;78     	uint8_t x,y;
;;;79     		GPIOA->BSRRH = GPIO_Pin_4;
000002  4918              LDR      r1,|L1.100|
000004  2010              MOVS     r0,#0x10
000006  8348              STRH     r0,[r1,#0x1a]
;;;80         Switch_to_Command();    // Переключение в режим команд
000008  f7fffffe          BL       Switch_to_Command
;;;81     
;;;82         OLED_Write(0x20);        // Ориентация и развертка дисплея
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       OLED_Write
;;;83         OLED_Write(0x00);        // автоинкремент страниц, слева направо, сверху вниз
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       OLED_Write
;;;84     
;;;85         OLED_Write(0x8D);        // Включение DC/DC
000018  208d              MOVS     r0,#0x8d
00001a  f7fffffe          BL       OLED_Write
;;;86         OLED_Write(0x14);        // конвертера
00001e  2014              MOVS     r0,#0x14
000020  f7fffffe          BL       OLED_Write
;;;87     
;;;88         Switch_to_Data();        // Переключение в режим данных
000024  f7fffffe          BL       Switch_to_Data
;;;89         Refresh_frame();        // Очистка дисплея
000028  f7fffffe          BL       Refresh_frame
;;;90     
;;;91         Switch_to_Command();    // Переключение в режим команд
00002c  f7fffffe          BL       Switch_to_Command
;;;92         OLED_Write(0xAF);        // Включение дисплея
000030  20af              MOVS     r0,#0xaf
000032  f7fffffe          BL       OLED_Write
;;;93     
;;;94         Switch_to_Data();        // Переключение в режим данных
000036  f7fffffe          BL       Switch_to_Data
;;;95     	
;;;96     		 /* чето такое рисуется, сетка какаято */
;;;97       for (y=0; y<8; y++)
00003a  2100              MOVS     r1,#0
;;;98       {
;;;99           for (x=0; x<128; x++)
;;;100          {
;;;101              if (!(x%8)) GRAM[y][x] = 0xE7;
00003c  23e7              MOVS     r3,#0xe7
00003e  4d0a              LDR      r5,|L1.104|
;;;102              else GRAM[y][x] = 0x81;
000040  2481              MOVS     r4,#0x81
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;99
000044  eb0512c1          ADD      r2,r5,r1,LSL #7       ;101
                  |L1.72|
000048  0746              LSLS     r6,r0,#29             ;101
00004a  d009              BEQ      |L1.96|
00004c  5414              STRB     r4,[r2,r0]
                  |L1.78|
00004e  1c40              ADDS     r0,r0,#1
000050  b2c0              UXTB     r0,r0                 ;99
000052  2880              CMP      r0,#0x80              ;99
000054  d3f8              BCC      |L1.72|
000056  1c49              ADDS     r1,r1,#1              ;99
000058  b2c9              UXTB     r1,r1                 ;97
00005a  2908              CMP      r1,#8                 ;97
00005c  d3f1              BCC      |L1.66|
;;;103          }
;;;104      }
;;;105    }//----------------------------------------------
00005e  bd70              POP      {r4-r6,pc}
                  |L1.96|
000060  5413              STRB     r3,[r2,r0]            ;101
000062  e7f4              B        |L1.78|
;;;106    /*-----------------------------------------------
                          ENDP

                  |L1.100|
                          DCD      0x40020000
                  |L1.104|
                          DCD      ||.bss||

                          AREA ||i.Interface_Init||, CODE, READONLY, ALIGN=2

                  Interface_Init PROC
;;;29      */
;;;30     void Interface_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;31     {
;;;32     		SPI_InitTypeDef SPI_InitStruct;
;;;33     	GPIO_InitTypeDef InitStruct;
;;;34     	GPIO_InitTypeDef GPIO_InitStructure_CS;
;;;35     	
;;;36     	// Стартуем тактирование SPI
;;;37     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000002  2101              MOVS     r1,#1
000004  b08a              SUB      sp,sp,#0x28           ;31
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;38     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;39     	
;;;40     		// Настраиваем ноги GPIO для сигналов SCK и MOSI
;;;41     	InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;
000014  20a0              MOVS     r0,#0xa0
;;;42     	InitStruct.GPIO_Mode = GPIO_Mode_AF;
000016  9005              STR      r0,[sp,#0x14]
000018  2002              MOVS     r0,#2
00001a  f88d0018          STRB     r0,[sp,#0x18]
;;;43     	InitStruct.GPIO_OType = GPIO_OType_PP;
00001e  2400              MOVS     r4,#0
000020  f88d401a          STRB     r4,[sp,#0x1a]
;;;44     	InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;45     	InitStruct.GPIO_Speed = GPIO_Speed_40MHz;
;;;46     	GPIO_Init(GPIOA, &InitStruct);
000024  4e24              LDR      r6,|L2.184|
000026  f88d401b          STRB     r4,[sp,#0x1b]         ;44
00002a  2503              MOVS     r5,#3                 ;45
00002c  f88d5019          STRB     r5,[sp,#0x19]         ;45
000030  a905              ADD      r1,sp,#0x14
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       GPIO_Init
;;;47     	
;;;48     	GPIO_InitStructure_CS.GPIO_Pin = GPIO_Pin_4;
;;;49     	GPIO_InitStructure_CS.GPIO_Mode = GPIO_Mode_OUT;
000038  2101              MOVS     r1,#1
00003a  f88d1020          STRB     r1,[sp,#0x20]
;;;50     	GPIO_InitStructure_CS.GPIO_OType = GPIO_OType_PP;
00003e  f88d4022          STRB     r4,[sp,#0x22]
000042  2010              MOVS     r0,#0x10              ;48
;;;51     	GPIO_InitStructure_CS.GPIO_Speed = GPIO_Speed_40MHz;
000044  f88d5021          STRB     r5,[sp,#0x21]
000048  9007              STR      r0,[sp,#0x1c]         ;49
;;;52     	GPIO_InitStructure_CS.GPIO_PuPd = GPIO_PuPd_UP;
00004a  f88d1023          STRB     r1,[sp,#0x23]
;;;53     	GPIO_Init(GPIOA, &GPIO_InitStructure_CS);
00004e  a907              ADD      r1,sp,#0x1c
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       GPIO_Init
;;;54     	
;;;55     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_SPI1);
000056  2205              MOVS     r2,#5
000058  4611              MOV      r1,r2
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       GPIO_PinAFConfig
;;;56     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_SPI1);
000060  2205              MOVS     r2,#5
000062  2107              MOVS     r1,#7
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       GPIO_PinAFConfig
;;;57     	
;;;58     	// Настраиваем SPI
;;;59     	//SPI_Cmd(SPI1, DISABLE);
;;;60     	SPI_StructInit(&SPI_InitStruct);
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       SPI_StructInit
;;;61     	SPI_InitStruct.SPI_Direction = SPI_Direction_1Line_Tx;
000070  03a8              LSLS     r0,r5,#14
000072  f8ad0000          STRH     r0,[sp,#0]
;;;62     	SPI_InitStruct.SPI_Mode = SPI_Mode_Master;
000076  f44f7082          MOV      r0,#0x104
00007a  f8ad0002          STRH     r0,[sp,#2]
;;;63     	SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;
;;;64     	SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;
;;;65     	SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;
00007e  f8ad4008          STRH     r4,[sp,#8]
;;;66     	SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;
000082  1570              ASRS     r0,r6,#21
000084  f8ad000a          STRH     r0,[sp,#0xa]
;;;67     	SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;
000088  2018              MOVS     r0,#0x18
00008a  f8ad000c          STRH     r0,[sp,#0xc]
00008e  f8ad4004          STRH     r4,[sp,#4]            ;63
000092  f8ad4006          STRH     r4,[sp,#6]            ;64
;;;68     	SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;
000096  f8ad400e          STRH     r4,[sp,#0xe]
;;;69     	SPI_InitStruct.SPI_CRCPolynomial = 7;
00009a  2007              MOVS     r0,#7
;;;70     	SPI_Init(SPI1, &SPI_InitStruct);
00009c  4c07              LDR      r4,|L2.188|
00009e  f8ad0010          STRH     r0,[sp,#0x10]         ;69
0000a2  4669              MOV      r1,sp
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       SPI_Init
;;;71     	SPI_Cmd(SPI1, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       SPI_Cmd
;;;72     }//----------------------------------------------
0000b2  b00a              ADD      sp,sp,#0x28
0000b4  bd70              POP      {r4-r6,pc}
;;;73     /*-----------------------------------------------
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
                          DCD      0x40020000
                  |L2.188|
                          DCD      0x40013000

                          AREA ||i.OLED_Write||, CODE, READONLY, ALIGN=2

                  OLED_Write PROC
;;;108     */
;;;109    void OLED_Write(uint8_t data)
000000  4902              LDR      r1,|L3.12|
                  |L3.2|
;;;110    {
;;;111        while (!(SPI1 ->SR & SPI_SR_TXE)) {}        // Ожидание свободного буфера передачи
000002  890a              LDRH     r2,[r1,#8]
000004  0792              LSLS     r2,r2,#30
000006  d5fc              BPL      |L3.2|
;;;112        SPI1->DR = data;                        // Запись байта в буфер передачи
000008  8188              STRH     r0,[r1,#0xc]
;;;113    }//---------------------------------
00000a  4770              BX       lr
;;;114    /*----------------------------------
                          ENDP

                  |L3.12|
                          DCD      0x40013000

                          AREA ||i.Refresh_frame||, CODE, READONLY, ALIGN=2

                  Refresh_frame PROC
;;;137     */
;;;138    void Refresh_frame(void)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {
;;;140    	uint8_t y, x;
;;;141        for (y = 0; y<8; y++)
;;;142        {
;;;143            for (x = 0; x<128; x++)
;;;144            {
;;;145                OLED_Write(GRAM[y][x]);            // Отправка байта данных
000002  4e08              LDR      r6,|L4.36|
000004  2400              MOVS     r4,#0                 ;141
                  |L4.6|
000006  2300              MOVS     r3,#0                 ;143
000008  eb0615c4          ADD      r5,r6,r4,LSL #7
                  |L4.12|
00000c  5ce8              LDRB     r0,[r5,r3]
00000e  f7fffffe          BL       OLED_Write
000012  1c5b              ADDS     r3,r3,#1
000014  b2db              UXTB     r3,r3                 ;143
000016  2b80              CMP      r3,#0x80              ;143
000018  d3f8              BCC      |L4.12|
00001a  1c64              ADDS     r4,r4,#1              ;143
00001c  b2e4              UXTB     r4,r4                 ;141
00001e  2c08              CMP      r4,#8                 ;141
000020  d3f1              BCC      |L4.6|
;;;146            }
;;;147        }
;;;148    }//---------------------------------------------- 
000022  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L4.36|
                          DCD      ||.bss||

                          AREA ||i.Switch_to_Command||, CODE, READONLY, ALIGN=2

                  Switch_to_Command PROC
;;;116     */
;;;117    void Switch_to_Command(void)
000000  4803              LDR      r0,|L5.16|
                  |L5.2|
;;;118    {
;;;119        while (SPI1 ->SR & SPI_SR_BSY) {}        // Ожидание завершения передачи
000002  8901              LDRH     r1,[r0,#8]
000004  0609              LSLS     r1,r1,#24
000006  d4fc              BMI      |L5.2|
;;;120        //GPIOA - ›BSRR = GPIO_BSRR_BR2;            // DC = 0
;;;121    		GPIOA->BSRRH = GPIO_Pin_2;
000008  4902              LDR      r1,|L5.20|
00000a  2004              MOVS     r0,#4
00000c  8348              STRH     r0,[r1,#0x1a]
;;;122    }//---------------------------------
00000e  4770              BX       lr
;;;123    /*----------------------------------
                          ENDP

                  |L5.16|
                          DCD      0x40013000
                  |L5.20|
                          DCD      0x40020000

                          AREA ||i.Switch_to_Data||, CODE, READONLY, ALIGN=2

                  Switch_to_Data PROC
;;;125     */
;;;126    void Switch_to_Data(void)
000000  4803              LDR      r0,|L6.16|
                  |L6.2|
;;;127    {
;;;128        while (SPI1 ->SR & SPI_SR_BSY) {}        // Ожидание завершения передачи
000002  8901              LDRH     r1,[r0,#8]
000004  0609              LSLS     r1,r1,#24
000006  d4fc              BMI      |L6.2|
;;;129        //GPIOA - ›BSRR = GPIO_BSRR_BS2;            // DC = 1
;;;130    		GPIOA->BSRRL = GPIO_Pin_2;
000008  4902              LDR      r1,|L6.20|
00000a  2004              MOVS     r0,#4
00000c  8308              STRH     r0,[r1,#0x18]
;;;131    		
;;;132    }//----------------------------------
00000e  4770              BX       lr
;;;133    
                          ENDP

                  |L6.16|
                          DCD      0x40013000
                  |L6.20|
                          DCD      0x40020000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  GRAM
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\src\\test.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_test_c_122c2e1a____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_test_c_122c2e1a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_test_c_122c2e1a____REVSH|
#line 144
|__asm___6_test_c_122c2e1a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
