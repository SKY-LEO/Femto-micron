; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_i2c.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_i2c.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32L1xx -D__MICROLIB -D__UVISION_VERSION=522 -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_i2c.crf ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;507      */
;;;508    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;509    {
;;;510      /* Check the parameters */
;;;511      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;512      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;513      if (NewState != DISABLE)
;;;514      {
;;;515        /* Enable the selected I2C ARP */
;;;516        I2Cx->CR1 |= I2C_CR1_ENARP;
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable the selected I2C ARP */
;;;521        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10           ;516
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L1.16|
000010  8001              STRH     r1,[r0,#0]            ;516
;;;522      }
;;;523    }
000012  4770              BX       lr
;;;524    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;359      */
;;;360    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;364      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;365      if (NewState != DISABLE)
;;;366      {
;;;367        /* Enable the acknowledgement */
;;;368        I2Cx->CR1 |= I2C_CR1_ACK;
;;;369      }
;;;370      else
;;;371      {
;;;372        /* Disable the acknowledgement */
;;;373        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400          ;368
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L2.16|
000010  8001              STRH     r1,[r0,#0]            ;368
;;;374      }
;;;375    }
000012  4770              BX       lr
;;;376    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;762      */
;;;763    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;764    {
;;;765      /* Check the parameters */
;;;766      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;767      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;768      if (NewState != DISABLE)
;;;769      {
;;;770        /* Enable the selected I2C PEC calculation */
;;;771        I2Cx->CR1 |= I2C_CR1_ENPEC;
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the selected I2C PEC calculation */
;;;776        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410120          ORR      r1,r1,#0x20           ;771
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;771
;;;777      }
;;;778    }
000012  4770              BX       lr
;;;779    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1057     */
;;;1058   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  4602              MOV      r2,r0
;;;1059   {
;;;1060     uint32_t lastevent = 0;
;;;1061     uint32_t flag1 = 0, flag2 = 0;
;;;1062     ErrorStatus status = ERROR;
000002  2000              MOVS     r0,#0
;;;1063   
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1066     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1067   
;;;1068     /* Read the I2Cx status register */
;;;1069     flag1 = I2Cx->SR1;
000004  8a93              LDRH     r3,[r2,#0x14]
;;;1070     flag2 = I2Cx->SR2;
000006  8b12              LDRH     r2,[r2,#0x18]
;;;1071     flag2 = flag2 << 16;
;;;1072   
;;;1073     /* Get the last event value from I2C status register */
;;;1074     lastevent = (flag1 | flag2) & FLAG_MASK;
000008  ea434302          ORR      r3,r3,r2,LSL #16
00000c  f023427f          BIC      r2,r3,#0xff000000
;;;1075   
;;;1076     /* Check whether the last event contains the I2C_EVENT */
;;;1077     if ((lastevent & I2C_EVENT) == I2C_EVENT)
000010  4391              BICS     r1,r1,r2
000012  d100              BNE      |L4.22|
;;;1078     {
;;;1079       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1080       status = SUCCESS;
000014  2001              MOVS     r0,#1
                  |L4.22|
;;;1081     }
;;;1082     else
;;;1083     {
;;;1084       /* ERROR: last event is different from I2C_EVENT */
;;;1085       status = ERROR;
;;;1086     }
;;;1087     /* Return status */
;;;1088     return status;
;;;1089   }
000016  4770              BX       lr
;;;1090   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1237     */
;;;1238   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1239   {
;;;1240     uint32_t flagpos = 0;
;;;1241     /* Check the parameters */
;;;1242     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1243     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1244     /* Get the I2C flag position */
;;;1245     flagpos = I2C_FLAG & FLAG_MASK;
;;;1246     /* Clear the selected I2C flag */
;;;1247     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1248   }
000004  4770              BX       lr
;;;1249   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1332     */
;;;1333   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1334   {
;;;1335     uint32_t flagpos = 0;
;;;1336     /* Check the parameters */
;;;1337     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1338     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1339     /* Get the I2C flag position */
;;;1340     flagpos = I2C_IT & FLAG_MASK;
;;;1341     /* Clear the selected I2C flag */
;;;1342     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1343   }
000004  4770              BX       lr
;;;1344   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;287      */
;;;288    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;289    {
;;;290      /* Check the parameters */
;;;291      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;292      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;293      if (NewState != DISABLE)
;;;294      {
;;;295        /* Enable the selected I2C peripheral */
;;;296        I2Cx->CR1 |= I2C_CR1_PE;
;;;297      }
;;;298      else
;;;299      {
;;;300        /* Disable the selected I2C peripheral */
;;;301        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;296
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;296
;;;302      }
;;;303    }
000012  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;816      */
;;;817    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;818    {
;;;819      /* Check the parameters */
;;;820      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;821      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;822      if (NewState != DISABLE)
;;;823      {
;;;824        /* Enable the selected I2C DMA requests */
;;;825        I2Cx->CR2 |= I2C_CR2_DMAEN;
;;;826      }
;;;827      else
;;;828      {
;;;829        /* Disable the selected I2C DMA requests */
;;;830        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L8.12|
000006  f4416100          ORR      r1,r1,#0x800          ;825
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L8.16|
000010  8081              STRH     r1,[r0,#4]            ;825
;;;831      }
;;;832    }
000012  4770              BX       lr
;;;833    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;840      */
;;;841    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;842    {
;;;843      /* Check the parameters */
;;;844      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;845      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;846      if (NewState != DISABLE)
;;;847      {
;;;848        /* Next DMA transfer is the last transfer */
;;;849        I2Cx->CR2 |= I2C_CR2_LAST;
;;;850      }
;;;851      else
;;;852      {
;;;853        /* Next DMA transfer is not the last transfer */
;;;854        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;849
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L9.16|
000010  8081              STRH     r1,[r0,#4]            ;849
;;;855      }
;;;856    }
000012  4770              BX       lr
;;;857    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;123      */
;;;124    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  4909              LDR      r1,|L10.40|
;;;125    {
000002  b510              PUSH     {r4,lr}
;;;126      /* Check the parameters */
;;;127      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;128    
;;;129      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
;;;130      {
;;;131        /* Enable I2C1 reset state */
;;;132        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;133        /* Release I2C1 from reset state */
;;;134        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;135      }
;;;136      else
;;;137      {
;;;138        /* Enable I2C2 reset state */
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000006  f04f0101          MOV      r1,#1
00000a  d101              BNE      |L10.16|
00000c  054c              LSLS     r4,r1,#21             ;132
00000e  e001              B        |L10.20|
                  |L10.16|
000010  f44f0480          MOV      r4,#0x400000
                  |L10.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;140        /* Release I2C2 from reset state */
;;;141        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00001a  4620              MOV      r0,r4
00001c  e8bd4010          POP      {r4,lr}
000020  2100              MOVS     r1,#0
000022  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;142      }
;;;143    }
;;;144    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;409      */
;;;410    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;411    {
;;;412      /* Check the parameters */
;;;413      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;414      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;415      if (NewState != DISABLE)
;;;416      {
;;;417        /* Enable dual addressing mode */
;;;418        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
;;;419      }
;;;420      else
;;;421      {
;;;422        /* Disable dual addressing mode */
;;;423        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1              ;418
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L11.16|
000010  8181              STRH     r1,[r0,#0xc]          ;418
;;;424      }
;;;425    }
000012  4770              BX       lr
;;;426    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;557      */
;;;558    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;562      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;563      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;564      {
;;;565        /* I2C fast mode Tlow/Thigh=2 */
;;;566        I2Cx->CCR &= I2C_DutyCycle_2;
;;;567      }
;;;568      else
;;;569      {
;;;570        /* I2C fast mode Tlow/Thigh=16/9 */
;;;571        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  d002              BEQ      |L12.14|
000008  f4214180          BIC      r1,r1,#0x4000         ;566
00000c  e001              B        |L12.18|
                  |L12.14|
00000e  f4414180          ORR      r1,r1,#0x4000
                  |L12.18|
000012  8381              STRH     r1,[r0,#0x1c]         ;566
;;;572      }
;;;573    }
000014  4770              BX       lr
;;;574    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;433      */
;;;434    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;435    {
;;;436      /* Check the parameters */
;;;437      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;438      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;439      if (NewState != DISABLE)
;;;440      {
;;;441        /* Enable generall call */
;;;442        I2Cx->CR1 |= I2C_CR1_ENGC;
;;;443      }
;;;444      else
;;;445      {
;;;446        /* Disable generall call */
;;;447        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L13.12|
000006  f0410140          ORR      r1,r1,#0x40           ;442
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L13.16|
000010  8001              STRH     r1,[r0,#0]            ;442
;;;448      }
;;;449    }
000012  4770              BX       lr
;;;450    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;311      */
;;;312    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;313    {
;;;314      /* Check the parameters */
;;;315      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;316      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;317      if (NewState != DISABLE)
;;;318      {
;;;319        /* Generate a START condition */
;;;320        I2Cx->CR1 |= I2C_CR1_START;
;;;321      }
;;;322      else
;;;323      {
;;;324        /* Disable the START condition generation */
;;;325        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4417180          ORR      r1,r1,#0x100          ;320
00000a  e001              B        |L14.16|
                  |L14.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L14.16|
000010  8001              STRH     r1,[r0,#0]            ;320
;;;326      }
;;;327    }
000012  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;335      */
;;;336    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;337    {
;;;338      /* Check the parameters */
;;;339      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;340      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;341      if (NewState != DISABLE)
;;;342      {
;;;343        /* Generate a STOP condition */
;;;344        I2Cx->CR1 |= I2C_CR1_STOP;
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Disable the STOP condition generation */
;;;349        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4417100          ORR      r1,r1,#0x200          ;344
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4217100          BIC      r1,r1,#0x200
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;344
;;;350      }
;;;351    }
000012  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1160     */
;;;1161   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1162   {
000002  4602              MOV      r2,r0
;;;1163     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1164     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1165   
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1168     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1169   
;;;1170     /* Get the I2Cx peripheral base address */
;;;1171     i2cxbase = (uint32_t)I2Cx;
;;;1172     
;;;1173     /* Read flag register index */
;;;1174     i2creg = I2C_FLAG >> 28;
000006  9200              STR      r2,[sp,#0]
000008  0f0a              LSRS     r2,r1,#28
;;;1175     
;;;1176     /* Get bit[23:0] of the flag */
;;;1177     I2C_FLAG &= FLAG_MASK;
00000a  f021417f          BIC      r1,r1,#0xff000000
00000e  9201              STR      r2,[sp,#4]            ;1162
000010  d002              BEQ      |L16.24|
;;;1178     
;;;1179     if(i2creg != 0)
;;;1180     {
;;;1181       /* Get the I2Cx SR1 register address */
;;;1182       i2cxbase += 0x14;
000012  9a00              LDR      r2,[sp,#0]
000014  3214              ADDS     r2,r2,#0x14
000016  e002              B        |L16.30|
                  |L16.24|
;;;1183     }
;;;1184     else
;;;1185     {
;;;1186       /* Flag in I2Cx SR2 Register */
;;;1187       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
;;;1188       /* Get the I2Cx SR2 register address */
;;;1189       i2cxbase += 0x18;
000018  9a00              LDR      r2,[sp,#0]
00001a  0c09              LSRS     r1,r1,#16             ;1187
00001c  3218              ADDS     r2,r2,#0x18
                  |L16.30|
;;;1190     }
;;;1191     
;;;1192     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00001e  9200              STR      r2,[sp,#0]
000020  6812              LDR      r2,[r2,#0]
000022  420a              TST      r2,r1
000024  d000              BEQ      |L16.40|
;;;1193     {
;;;1194       /* I2C_FLAG is set */
;;;1195       bitstatus = SET;
000026  2001              MOVS     r0,#1
                  |L16.40|
;;;1196     }
;;;1197     else
;;;1198     {
;;;1199       /* I2C_FLAG is reset */
;;;1200       bitstatus = RESET;
;;;1201     }
;;;1202     
;;;1203     /* Return the I2C_FLAG status */
;;;1204     return  bitstatus;
;;;1205   }
000028  bd0c              POP      {r2,r3,pc}
;;;1206   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1271     */
;;;1272   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1273   {
000002  4603              MOV      r3,r0
;;;1274     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1275     uint32_t enablestatus = 0;
;;;1276   
;;;1277     /* Check the parameters */
;;;1278     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1279     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1280   
;;;1281     /* Check if the interrupt source is enabled or not */
;;;1282     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000006  889a              LDRH     r2,[r3,#4]
000008  f44f64e0          MOV      r4,#0x700
00000c  ea044411          AND      r4,r4,r1,LSR #16
;;;1283     
;;;1284     /* Get bit[23:0] of the flag */
;;;1285     I2C_IT &= FLAG_MASK;
;;;1286   
;;;1287     /* Check the status of the specified I2C flag */
;;;1288     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000010  8a9b              LDRH     r3,[r3,#0x14]
000012  4022              ANDS     r2,r2,r4              ;1282
000014  f021417f          BIC      r1,r1,#0xff000000     ;1285
000018  420b              TST      r3,r1
00001a  d002              BEQ      |L17.34|
00001c  2a00              CMP      r2,#0
00001e  d000              BEQ      |L17.34|
;;;1289     {
;;;1290       /* I2C_IT is set */
;;;1291       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L17.34|
;;;1292     }
;;;1293     else
;;;1294     {
;;;1295       /* I2C_IT is reset */
;;;1296       bitstatus = RESET;
;;;1297     }
;;;1298     /* Return the I2C_IT status */
;;;1299     return  bitstatus;
;;;1300   }
000022  bd10              POP      {r4,pc}
;;;1301   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1105     */
;;;1106   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1107   {
;;;1108     uint32_t lastevent = 0;
;;;1109     uint32_t flag1 = 0, flag2 = 0;
;;;1110   
;;;1111     /* Check the parameters */
;;;1112     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1113   
;;;1114     /* Read the I2Cx status register */
;;;1115     flag1 = I2Cx->SR1;
;;;1116     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1117     flag2 = flag2 << 16;
;;;1118   
;;;1119     /* Get the last event value from I2C status register */
;;;1120     lastevent = (flag1 | flag2) & FLAG_MASK;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1121   
;;;1122     /* Return status */
;;;1123     return lastevent;
;;;1124   }
00000c  4770              BX       lr
;;;1125   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;784      */
;;;785    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;786    {
;;;787      /* Check the parameters */
;;;788      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;789      /* Return the selected I2C PEC value */
;;;790      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;791    }
000004  4770              BX       lr
;;;792    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1000     */
;;;1001   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1002   {
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1005     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1006     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1007     
;;;1008     if (NewState != DISABLE)
;;;1009     {
;;;1010       /* Enable the selected I2C interrupts */
;;;1011       I2Cx->CR2 |= I2C_IT;
;;;1012     }
;;;1013     else
;;;1014     {
;;;1015       /* Disable the selected I2C interrupts */
;;;1016       I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L20.10|
000006  430a              ORRS     r2,r2,r1              ;1011
000008  e000              B        |L20.12|
                  |L20.10|
00000a  438a              BICS     r2,r2,r1
                  |L20.12|
00000c  8082              STRH     r2,[r0,#4]            ;1011
;;;1017     }
;;;1018   }
00000e  4770              BX       lr
;;;1019   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;154      */
;;;155    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;156    {
000002  4604              MOV      r4,r0
;;;157      uint16_t tmpreg = 0, freqrange = 0;
;;;158      uint16_t result = 0x04;
;;;159      uint32_t pclk1 = 8000000;
;;;160      RCC_ClocksTypeDef  rcc_clocks;
;;;161      /* Check the parameters */
;;;162      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;163      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;164      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;165      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;166      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;167      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;168      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;169    
;;;170    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;171      /* Get the I2Cx CR2 value */
;;;172      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  460d              MOV      r5,r1                 ;156
;;;173      /* Clear frequency FREQ[5:0] bits */
;;;174      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
000008  f020063f          BIC      r6,r0,#0x3f
;;;175      /* Get pclk1 frequency value */
;;;176      RCC_GetClocksFreq(&rcc_clocks);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       RCC_GetClocksFreq
;;;177      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;178      /* Set frequency bits depending on pclk1 value */
;;;179      freqrange = (uint16_t)(pclk1 / 1000000);
000012  4927              LDR      r1,|L21.176|
000014  9802              LDR      r0,[sp,#8]
000016  fbb0f1f1          UDIV     r1,r0,r1
00001a  b289              UXTH     r1,r1
;;;180      tmpreg |= freqrange;
00001c  430e              ORRS     r6,r6,r1
;;;181      /* Write to I2Cx CR2 */
;;;182      I2Cx->CR2 = tmpreg;
00001e  80a6              STRH     r6,[r4,#4]
;;;183    
;;;184    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;185      /* Disable the selected I2C peripheral to configure TRISE */
;;;186      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000020  8822              LDRH     r2,[r4,#0]
000022  f0220201          BIC      r2,r2,#1
000026  8022              STRH     r2,[r4,#0]
;;;187      /* Reset tmpreg value */
;;;188      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;189      tmpreg = 0;
;;;190    
;;;191      /* Configure speed in standard mode */
;;;192      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000028  4b22              LDR      r3,|L21.180|
00002a  682a              LDR      r2,[r5,#0]
00002c  429a              CMP      r2,r3
00002e  d81b              BHI      |L21.104|
;;;193      {
;;;194        /* Standard mode speed calculate */
;;;195        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000030  0052              LSLS     r2,r2,#1
000032  fbb0f0f2          UDIV     r0,r0,r2
000036  b280              UXTH     r0,r0
;;;196        /* Test if CCR value is under 0x4*/
;;;197        if (result < 0x04)
000038  2804              CMP      r0,#4
00003a  d200              BCS      |L21.62|
;;;198        {
;;;199          /* Set minimum allowed value */
;;;200          result = 0x04;  
00003c  2004              MOVS     r0,#4
                  |L21.62|
00003e  1c49              ADDS     r1,r1,#1
;;;201        }
;;;202        /* Set speed value for standard mode */
;;;203        tmpreg |= result;	  
;;;204        /* Set Maximum Rise Time for standard mode */
;;;205        I2Cx->TRISE = freqrange + 1; 
000040  8421              STRH     r1,[r4,#0x20]
;;;206      }
;;;207      /* Configure speed in fast mode */
;;;208      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;209         input clock) must be a multiple of 10 MHz */
;;;210      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;211      {
;;;212        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;213        {
;;;214          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;215          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;216        }
;;;217        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;218        {
;;;219          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;220          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;221          /* Set DUTY bit */
;;;222          result |= I2C_DutyCycle_16_9;
;;;223        }
;;;224    
;;;225        /* Test if CCR value is under 0x1*/
;;;226        if ((result & I2C_CCR_CCR) == 0)
;;;227        {
;;;228          /* Set minimum allowed value */
;;;229          result |= (uint16_t)0x0001;  
;;;230        }
;;;231        /* Set speed value and set F/S bit for fast mode */
;;;232        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
;;;233        /* Set Maximum Rise Time for fast mode */
;;;234        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;235      }
;;;236    
;;;237      /* Write to I2Cx CCR */
;;;238      I2Cx->CCR = tmpreg;
000042  83a0              STRH     r0,[r4,#0x1c]
;;;239      /* Enable the selected I2C peripheral */
;;;240      I2Cx->CR1 |= I2C_CR1_PE;
000044  8820              LDRH     r0,[r4,#0]
000046  f0400001          ORR      r0,r0,#1
00004a  8020              STRH     r0,[r4,#0]
;;;241    
;;;242    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;243      /* Get the I2Cx CR1 value */
;;;244      tmpreg = I2Cx->CR1;
00004c  8821              LDRH     r1,[r4,#0]
;;;245      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;246      tmpreg &= CR1_CLEAR_MASK;
00004e  f64f30f5          MOV      r0,#0xfbf5
000052  4001              ANDS     r1,r1,r0
;;;247      /* Configure I2Cx: mode and acknowledgement */
;;;248      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;249      /* Set ACK bit according to I2C_Ack value */
;;;250      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000054  88a8              LDRH     r0,[r5,#4]
000056  896a              LDRH     r2,[r5,#0xa]
000058  4310              ORRS     r0,r0,r2
00005a  4308              ORRS     r0,r0,r1
;;;251      /* Write to I2Cx CR1 */
;;;252      I2Cx->CR1 = tmpreg;
00005c  8020              STRH     r0,[r4,#0]
;;;253    
;;;254    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;255      /* Set I2Cx Own Address1 and acknowledged address */
;;;256      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
00005e  89a8              LDRH     r0,[r5,#0xc]
000060  8929              LDRH     r1,[r5,#8]
000062  4308              ORRS     r0,r0,r1
000064  8120              STRH     r0,[r4,#8]
;;;257    }
000066  bd7f              POP      {r0-r6,pc}
                  |L21.104|
000068  88eb              LDRH     r3,[r5,#6]            ;212
00006a  f5a3463f          SUB      r6,r3,#0xbf00         ;212
00006e  3eff              SUBS     r6,r6,#0xff           ;212
000070  d00b              BEQ      |L21.138|
000072  eb0203c2          ADD      r3,r2,r2,LSL #3       ;220
000076  eb031202          ADD      r2,r3,r2,LSL #4       ;220
00007a  fbb0f0f2          UDIV     r0,r0,r2              ;220
00007e  b280              UXTH     r0,r0                 ;220
000080  f4404080          ORR      r0,r0,#0x4000         ;222
                  |L21.132|
000084  0502              LSLS     r2,r0,#20             ;226
000086  d006              BEQ      |L21.150|
000088  e007              B        |L21.154|
                  |L21.138|
00008a  eb020242          ADD      r2,r2,r2,LSL #1       ;215
00008e  fbb0f0f2          UDIV     r0,r0,r2              ;215
000092  b280              UXTH     r0,r0                 ;215
000094  e7f6              B        |L21.132|
                  |L21.150|
000096  f0400001          ORR      r0,r0,#1              ;229
                  |L21.154|
00009a  f44f7296          MOV      r2,#0x12c             ;234
00009e  4351              MULS     r1,r2,r1              ;234
0000a0  f44f727a          MOV      r2,#0x3e8             ;234
0000a4  fbb1f1f2          UDIV     r1,r1,r2              ;234
0000a8  f4404000          ORR      r0,r0,#0x8000         ;232
0000ac  e7c7              B        |L21.62|
;;;258    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L21.176|
                          DCD      0x000f4240
                  |L21.180|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;667      */
;;;668    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;669    {
;;;670      /* Check the parameters */
;;;671      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;672      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;673      
;;;674      /* Check the input parameter */
;;;675      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;676      {
;;;677        /* Next byte in shift register is the last received byte */
;;;678        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;679      }
;;;680      else
;;;681      {
;;;682        /* Current byte in shift register is the last received byte */
;;;683        I2Cx->CR1 &= I2C_NACKPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L22.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L22.12|
00000c  8001              STRH     r1,[r0,#0]            ;678
;;;684      }
;;;685    }
00000e  4770              BX       lr
                  |L22.16|
000010  f4416100          ORR      r1,r1,#0x800          ;678
000014  e7fa              B        |L22.12|
;;;686    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;382      */
;;;383    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;384    {
;;;385      uint16_t tmpreg = 0;
;;;386    
;;;387      /* Check the parameters */
;;;388      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;389    
;;;390      /* Get the old register value */
;;;391      tmpreg = I2Cx->OAR2;
;;;392    
;;;393      /* Reset I2Cx Own address2 bit [7:1] */
;;;394      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
;;;395    
;;;396      /* Set I2Cx Own address2 */
;;;397      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;394
00000a  4311              ORRS     r1,r1,r2
;;;398    
;;;399      /* Store the new register value */
;;;400      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;401    }
00000e  4770              BX       lr
;;;402    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;738      */
;;;739    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;740    {
;;;741      /* Check the parameters */
;;;742      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;743      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;744      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;745      {
;;;746        /* Next byte in shift register is PEC */
;;;747        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;748      }
;;;749      else
;;;750      {
;;;751        /* Current byte in shift register is PEC */
;;;752        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L24.16|
000008  f4216100          BIC      r1,r1,#0x800
                  |L24.12|
00000c  8001              STRH     r1,[r0,#0]            ;747
;;;753      }
;;;754    }
00000e  4770              BX       lr
                  |L24.16|
000010  f4416100          ORR      r1,r1,#0x800          ;747
000014  e7fa              B        |L24.12|
;;;755    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;973      */
;;;974    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;975    {
;;;976      __IO uint32_t tmp = 0;
;;;977    
;;;978      /* Check the parameters */
;;;979      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;980      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;981    
;;;982      tmp = (uint32_t) I2Cx;
;;;983      tmp += I2C_Register;
000002  4408              ADD      r0,r0,r1
;;;984    
;;;985      /* Return the selected register value */
;;;986      return (*(__IO uint16_t *) tmp);
000004  9000              STR      r0,[sp,#0]
000006  8800              LDRH     r0,[r0,#0]
;;;987    }
000008  bd08              POP      {r3,pc}
;;;988    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;639      */
;;;640    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;641    {
;;;642      /* Check the parameters */
;;;643      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;644      /* Return the data in the DR register */
;;;645      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;646    }
000004  4770              BX       lr
;;;647    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;483      */
;;;484    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;485    {
;;;486      /* Check the parameters */
;;;487      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;488      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;489      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;490      {
;;;491        /* Drive the SMBusAlert pin Low */
;;;492        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;493      }
;;;494      else
;;;495      {
;;;496        /* Drive the SMBusAlert pin High  */
;;;497        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L27.16|
000008  f4215100          BIC      r1,r1,#0x2000
                  |L27.12|
00000c  8001              STRH     r1,[r0,#0]            ;492
;;;498      }
;;;499    }
00000e  4770              BX       lr
                  |L27.16|
000010  f4415100          ORR      r1,r1,#0x2000         ;492
000014  e7fa              B        |L27.12|
;;;500    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;584      */
;;;585    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;586    {
;;;587      /* Check the parameters */
;;;588      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;589      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;590      /* Test on the direction to set/reset the read/write bit */
;;;591      if (I2C_Direction != I2C_Direction_Transmitter)
;;;592      {
;;;593        /* Set the address bit0 for read */
;;;594        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L28.12|
                  |L28.8|
;;;595      }
;;;596      else
;;;597      {
;;;598        /* Reset the address bit0 for write */
;;;599        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L28.12|
;;;600      }
;;;601      /* Send the address */
;;;602      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;603    }
00000e  4770              BX       lr
;;;604    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;626      */
;;;627    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;628    {
;;;629      /* Check the parameters */
;;;630      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;631      /* Write in the DR register the data to be sent */
;;;632      I2Cx->DR = Data;
;;;633    }
000002  4770              BX       lr
;;;634    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;457      */
;;;458    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;459    {
;;;460      /* Check the parameters */
;;;461      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;462      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;463      if (NewState != DISABLE)
;;;464      {
;;;465        /* Peripheral under reset */
;;;466        I2Cx->CR1 |= I2C_CR1_SWRST;
;;;467      }
;;;468      else
;;;469      {
;;;470        /* Peripheral not under reset */
;;;471        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L30.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;466
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L30.16|
000010  8001              STRH     r1,[r0,#0]            ;466
;;;472      }
;;;473    }
000012  4770              BX       lr
;;;474    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;531      */
;;;532    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;533    {
;;;534      /* Check the parameters */
;;;535      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;536      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;537      if (NewState == DISABLE)
;;;538      {
;;;539        /* Enable the selected I2C Clock stretching */
;;;540        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;541      }
;;;542      else
;;;543      {
;;;544        /* Disable the selected I2C Clock stretching */
;;;545        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000002  8801              LDRH     r1,[r0,#0]
000004  d003              BEQ      |L31.14|
000006  f0210180          BIC      r1,r1,#0x80
                  |L31.10|
00000a  8001              STRH     r1,[r0,#0]            ;540
;;;546      }
;;;547    }
00000c  4770              BX       lr
                  |L31.14|
00000e  f0410180          ORR      r1,r1,#0x80           ;540
000012  e7fa              B        |L31.10|
;;;548    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;263      */
;;;264    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;265    {
;;;266    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;267      /* initialize the I2C_ClockSpeed member */
;;;268      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;269      /* Initialize the I2C_Mode member */
;;;270      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;271      /* Initialize the I2C_DutyCycle member */
;;;272      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;273      /* Initialize the I2C_OwnAddress1 member */
;;;274      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;275      /* Initialize the I2C_Ack member */
;;;276      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;277      /* Initialize the I2C_AcknowledgedAddress member */
;;;278      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;279    }
00001a  4770              BX       lr
;;;280    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;709      */
;;;710    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;714      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;715      if (NewState != DISABLE)
;;;716      {
;;;717        /* Enable the selected I2C PEC transmission */
;;;718        I2Cx->CR1 |= I2C_CR1_PEC;
;;;719      }
;;;720      else
;;;721      {
;;;722        /* Disable the selected I2C PEC transmission */
;;;723        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L33.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;718
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L33.16|
000010  8001              STRH     r1,[r0,#0]            ;718
;;;724      }
;;;725    }
000012  4770              BX       lr
;;;726    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_i2c_c_7174d409____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_i2c_c_7174d409____REVSH|
#line 144
|__asm___15_stm32l1xx_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
